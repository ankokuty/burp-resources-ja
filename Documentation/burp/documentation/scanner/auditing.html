<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../assets/ps/styles/pssupportnav.css">
</head>
<body>
<section class="container ps-breadcrumbs">
    <ol>
        <li>
            <a href="https://support.portswigger.net/">サポートセンター</a>
        </li>
        <li>
            <a href="../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="index.html">Scanner</a>
        </li>
        <li>
            <a href="auditing.html">診断</a>
        </li>
    </ol>
</section>
<section class="container labels-editions-wrapper">
    <label class="label-edition is-enterprise">エンタープライズ</label>
    <label class="label-edition is-professional">プロフェッショナル</label>
</section>
<section class="maincontainer">
    <div class="container main">
        <h1>診断</h1>
        <p>
            スキャンの診断段階では、アプリケーションのトラフィックと挙動を分析して、セキュリティ上の脆弱性やその他の問題点を発見します。Burp Scanner広範囲の技術を駆使して、スキャン対象に対して、網羅性が高く、完全に正確な診断を実施します。
        </p>
        <h2 id="audit-phases">診断フェーズ</h2>
        <p>
            Burp Scannerは、いくつかの診断フェーズを実行します。これらは3つの領域に分かれています:
        </p>
        <ul>
            <li>
                パッシブフェーズ
            </li>
            <li>
                アクティブフェーズ
            </li>
            <li>
                JavaScript解析フェーズ
            </li>
        </ul>
        <p>
            各エリア内で複数のフェーズを実行するため、Burpは次のことが可能です:
        </p>
        <ul>
            <li>
                ユーザ入力を格納して返す関数を効果的に見つけて攻撃します。
            </li>
            <li>
                頻繁に発生する問題や挿入ポイントを最適な方法で処理し、重複を避けます。
            </li>
            <li>
                適切な作業を並行して実行して、システムリソースを最も効率的に使用する。
            </li>
        </ul>
        <h2 id="issue-types">問題の種類</h2>
        <p>
            Burpは、セキュリティ上の脆弱性やその他の重要な情報など、膨大な種類の問題を検出できます。
        </p>
        <p>
            問題は、診断アクティビティの性質に応じて、異なるタイプに分類できます:
        </p>
        <ul>
            <li>
                パッシブ - アプリケーションの通常のリクエストとレスポンスを調べるだけで検出できる問題です。例えば、<a href="https://portswigger.net/kb/issues/00400900_serialized-object-in-http-message">HTTPメッセージ内のシリアライズオブジェクト</a>などです。
            </li>
            <li>
                ライトアクティブ - 少数の良性な追加リクエストで検出できる問題です。例えば、<a href="https://portswigger.net/kb/issues/00200601_cross-origin-resource-sharing-arbitrary-origin-trusted">任意のオリジンを信頼しているクロスオリジンリソース共有(CORS)</a>などです。
            </li>
            <li>
                ミディアムアクティブ - アプリケーションがまあまあ悪意があると見なす可能性があるリクエストで検出できる問題です。例えば、<a href="https://portswigger.net/kb/issues/00100100_os-command-injection">OSコマンドインジェクション</a>などです。
            </li>
            <li>
                攻撃的アクティブ - アプリケーションやデータに大きな損害を与えるリクエストで検出できる問題です。例えば、<a href="https://portswigger.net/kb/issues/00100200_sql-injection">SQLインジェクション</a>などです。
            </li>
            <li>
                JavaScript解析 - アプリケーションがクライアント側で実行するJavaScriptを解析して検出できる問題です。例えば、DOMベースクロスサイトスクリプティングなどです。これらの問題を検出する際、Burpが実行されているマシンでリソースが集中的に使用されます。これらの問題は、"パッシブ"(自己完結型DOMベースの問題など)または、"ミディアムアクティブ"(反射および蓄積型など)に分類もできます。
            </li>
        </ul>
        <p>
            問題は、見つかったレベルに応じて異なるタイプにも分けられます:
        </p>
        <ul>
            <li>
                ホストレベル - アプリケーションが実行されているホストのHTTPサービスレベルで発生する問題です。例えば、寛容な<a href="https://portswigger.net/kb/issues/00200400_flash-cross-domain-policy">Flashクロスドメインポリシー</a>などです。
            </li>
            <li>
                リクエストレベル - 個々のリクエストレベルで発生する問題です。例えば、<a href="https://portswigger.net/kb/issues/00200700_cross-site-request-forgery">クロスサイトリクエストフォージェリ</a>などです。
            </li>
            <li>
                挿入ポイントレベル - リクエスト内の挿入ポイントレベルで発生する問題です。例えば、<a href="https://portswigger.net/kb/issues/00100300_file-path-traversal">ファイルパストラバーサル</a>などです。
            </li>
        </ul>
        <h2 id="insertion-points">挿入ポイント</h2>
        <p>
            Burp Scannerは挿入ポイントの概念を使用して、リクエスト内の様々な場所にペイロードを配置します。一般的に挿入ポイントとは、サーバ側アプリケーションによって特別に処理される可能性がある、リクエスト内のデータ部分を表します。次の例は、一般的なタイプの挿入ポイントを強調表示したリクエストです:
        </p>
        <img src="../images/auditing/auditing-1.svg" alt="スキャン挿入ポイント">
        <p>
            Burp Scannerは挿入ポイントを個別に診断し、各挿入ポイントにペイロードを送信して、アプリケーションがその入力を処理するかどうかをテストします。
        </p>
        <h3 id="encoding-data-within-insertion-points">挿入ポイント内でのデータエンコード</h3>
        <p>
            HTTPリクエスト内の様々な場所では通常、データのエンコード方法が異なります。Burp Scannerは、挿入ポイントの種類によってペイロードに適切なエンコーディングを自動的に適用し、関連するアプリケーション機能に生のペイロードが確実に到達するようにします。たとえば、標準のボディパラメータでも、異なるエンコーディングが適用されます:
        </p>
        <img src="../images/auditing/auditing-2.svg" alt="ボディパラメータ内のスキャンペイロードのURLエンコード">
        <p>
            JSONデータ内の場合:
        </p>
        <img src="../images/auditing/auditing-3.svg" alt="JSONデータ内のスキャンペイロードのエンコード">
        <p>
            XMLデータ内の場合:
        </p>
        <img src="../images/auditing/auditing-4.svg" alt="XMLデータ内のスキャンペイロードのエンコード">
        <p>
            Burp Scannerは、Base64など、挿入ポイントの種類に関連しない他のタイプのエンコーディングをアプリケーションが使用していることも検出します。
        </p>
        <img src="../images/auditing/auditing-5.svg" alt="Base64データ内のスキャンペイロードのエンコード">
        <h3 id="nested-insertion-points">ネストされた挿入ポイント</h3>
        <p>
            一部のアプリケーションは、同じデータに対して多段階のエンコーディングを適用し、あるフォーマットを別のフォーマットの中に効果的にネストします。Burp Scannerはこの動作を検出し、ペイロードに対して同じ階層のエンコードを自動的に適用します。
        </p>
        <img src="../images/auditing/auditing-6.svg" alt="ネストされた挿入ポイント内のスキャンペイロードのエンコード">
        <h3 id="modifying-parameter-locations">パラメータ位置の操作</h3>
        <p>
            一部のアプリケーションでは、特定タイプのパラメータに入力を配置させますが、異なるタイプのパラメータで入力を行っても実際は処理されることがあるでしょう。これは一部のプラットフォームで、アプリケーションがリクエストから入力を取り出す際のAPIが、パラメータがどこに入力されたかとは無関係に取り出すために発生します。ただし、Webアプリケーションファイアウォールなど、アプリケーションの周囲にある一部の防御機能は、元のパラメータタイプにのみ適用される場合があります。
        </p>
        <p>
            Burpはこの動作を悪用し、挿入ポイントのパラメータタイプを変更し、防御を突破して脆弱なアプリケーション機能に到達するリクエストの作成もできます。例えば、ペイロードがURLクエリーストリングパラメータとして送信される場合、Burpは対応するパラメータをボディパラメータやcookieで送信する場合があります:
        </p>
        <img src="../images/auditing/auditing-7.svg" alt="HTTPリクエスト内のパラメータ位置の操作">
        <h2 id="automatic-session-handling">自動セッションハンドリング</h2>
        <p>
            自動クロールに続いてBurp Scannerの診断が行われる場合、クロール結果を利用して診断中のセッションを自動的に維持できます。ユーザの設定は不要です。
        </p>
        <p>
            Burpは個々のリクエストを診断する際、クロールの開始位置からそのリクエストに到達する最短経路を特定します。
        </p>
        <img src="../images/auditing/auditing-8.svg" alt="開始URLから診断リクエストまでの全経路">
        <p>
            そして、有効なセッション内で同じリクエストを繰り返し送信する、最も効率的な方法を決定します。最初に経路を再巡回して新鮮なセッショントークンのサンプルを取得し、経路を様々な方法で単純化したテストを行い、セッションが正しく維持されているかどうかを確認します。
        </p>
        <p>
            多くの場合、最終リクエストを何度も何度も再発行ができます。リクエストにセッショントークンがまったく含まれていない場合に可能です:
        </p>
        <img src="../images/auditing/auditing-9.svg" alt="セッショントークンが含まれていない場合、最終リクエストを繰り返し発行">
        <p>
            あるいは、セッショントークンがcookieだけにあり、通常は複数回使用できます:
        </p>
        <img src="../images/auditing/auditing-10.svg" alt="セッショントークンがcookieのみの場合、最終リクエストを繰り返し発行">
        <p>
            または、リクエストにcookieとCSRFトークンの両方が含まれており、CSRFトークンを繰り返し使用できる場合も可能です:
        </p>
        <img src="../images/auditing/auditing-11.svg" alt="CSRFトークンが複数回利用できる場合、最終リクエストを繰り返し発行">
        <p>
            場合によって、診断するリクエストを発行する前に、前のリクエストを発行する必要があります。これは通常、アプリケーションがワンタイムCSRFトークンを使用する場合に発生します。トークンが1回しか使用できない場合、新しいトークンを取得するためにその都度先行したリクエストを再発行する必要があります。
        </p>
        <img src="../images/auditing/auditing-12.svg" alt="各最終リクエストの前に先行リクエストを発行し、新鮮なワンタイムCSRFトークンを取得する">
        <p>
            極端な場合、リクエスト間のすべての遷移がワンタイムトークンによって保護されます。これは、ナビゲーションが綿密に制御されている高セキュリティアプリケーションでたまにあります。この状況で、診断されるリクエストを繰り返し発行する最も信頼性の高い方法は、常に開始位置に戻り、そのリクエストへの完全な経路をたどることです。
        </p>
        <img src="../images/auditing/auditing-13.svg" alt="有効なCSRFトークンが確実に使われるよう、開始URLから全経路をたどる">
        <p>
            診断するリクエストを繰り返し発行する最も効率的な方法が決定すると、診断が実行されます。さまざまな診断チェックを実行しながら、Burpはアプリケーションのレスポンスを定期的に監視して、有効なセッションが確実に維持されるようにします。Burpがセッションの有効性を確実に確認すると、全て完了した診断チェックにチェックポイントが設定されます。セッションが無効になったとBurpが認識した場合、最新のチェックポイントにロールバックしてそこから再開します。このロジックは、セッション管理のオーバーヘッドを最小限に抑え、セッションが頻繁に失われた場合の無限ループを回避する方法で実行されます。例:
        </p>
        <img src="../images/auditing/auditing-14.svg" alt="最終チェックポイントまでロールバックして脆弱性スキャン中のセッションを自動的に維持する">
        <h2 id="avoiding-duplication">重複の回避</h2>
        <p>
            Burp Scannerは、重複した作業や重複した問題の報告を最小限に抑えるために、さまざまな手法を使用します。
        </p>
        <h3 id="consolidation-of-frequently-occurring-passive-issues">頻繁に発生するパッシブ問題の統合</h3>
        <p>
            一部のパッシブに検出された問題(クロスサイトリクエストフォージェリやクロスドメインスクリプトインクルードなど)は、開発で選択したアプローチやページテンプレートの再利用によるもので、アプリケーション内のさまざまな場所に存在する可能性があります。一部の問題は、プラットフォームレベルの設定 (厳密なトランスポートセキュリティが実施されていないなど)のために、アプリケーション全体に存在することもあります。このような場合Burp Scannerはデフォルトで、ホストのWebルートや全ての問題が見つかった特定のフォルダなど、該当するレベルに問題を集約し1つだけ報告して、重複した問題の生成を回避します。
        </p>
        <h3 id="handling-of-frequently-occurring-insertion-points">頻繁に発生する挿入ポイントの処理</h3>
        <p>
            一部の挿入ポイントは、アプリケーションで使用されるリクエストの多くまたは全てに存在していて、しかし興味深い攻撃経路ではないことがあります。例えばcookieで、一度セットされるとその後の全てのリクエストで送信されます。あるいはキャッシュバスターは、URLクエリーストリング内にありキャッシュを防止しますが、サーバ側のアプリケーションでは処理されません。これらの挿入ポイントを、リクエスト毎に全て診断を実行すると、無駄な作業にかなりの負荷が発生する可能性があります。このような場合Burp Scannerはデフォルトで、ほぼ問題がみつからない挿入ポイントを判別し、これらの挿入ポイントには軽度な診断を行うようになります。軽度な診断で、サーバ側の処理を示す興味深い挙動を見つけた場合は、Burpは通常通り挿入ポイントの完全な診断を実行し続けます。
        </p>
        <h2 id="javascript-analysis">JavaScript解析</h2>
        <p>
            Burp Scannerは、アプリケーションレスポンス内のJavaScriptを解析し、様々なDOMベースの脆弱性を発見します。これを行うには、静的解析と動的解析を組み合わせて使用します:
        </p>
        <ul>
            <li>
                静的解析 - JavaScriptコードを解析して抽象構文木 (ATS)を構築します。これによって、攻撃者が制御できる可能性がある汚染されたソースと、攻撃の実行に使用される危険なシンクを識別します。コード内で起こりうるデータフローを分析し潜在的なパスを発見し、汚染されたソースから入った悪意のあるデータが危険なシンクに渡る可能性がある経路を特定します。
            </li>
            <li>
                動的解析 - ヘッドレスの組み込みブラウザにレスポンスを読み込みます。攻撃者が制御できる可能性がある場所のDOMにペイロードを挿入し、レスポンス内でJavaScriptを実行します。またマウスイベントを作成して、(<span class="InlineCode">onclick</span>イベントハンドラーなど)可能な限り多くのコードを網羅しようとします。攻撃の実行に使用できる危険なシンクを監視し、挿入したペイロードがそれらのシンクに到達したかを特定します。
            </li>
        </ul>
        <p>
            静的アプローチと動的アプローチには、それぞれに長所と短所があります。
        </p>
        <ul>
            <li>
                静的解析では、動的解析中には実際に実行されない、適切な状況で実行できるコードパスを発見できるため、動的解析が見逃す脆弱性がいくつか見つかります。例えば、実行中の分岐は、攻撃者が制御する多数のパラメータで制御される可能性があります。静的解析ではこの分岐を識別して分析しその中の汚染された経路を発見できますが、動的解析では、実際に使用されるパラメータの組み合わせによってその動作を実行できない可能性があります。しかし静的解析はその性質上、過剰検知をしがちです。なぜなら、コードの分岐の組み合わせが実際には実行できない場合や、個別のデータ検証ロジックを理解できないため、ソースからシンクへの汚染された経路が実際には悪用できない場合があります。
            </li>
            <li>
                動的解析は、逆の特徴があります。汚染されたデータがソースからシンクに渡るのを実行中に実際に観察するため、この動作は脆弱性の具体的な証拠になり、過剰検知が起こりにくくなります。しかし、アプリケーションの現在の状態や他のデータの値によって、汚染されたデータがシンクに到達しない場合は、検出漏れを起こす可能性があります。しかし実際は攻撃者は両方ともコントロールできるかもしれません。
            </li>
        </ul>
        <p>
            Burp Scannerは、静的および動的アプローチの両方の利点を活用します。可能であれば、2つの手法の結果を対応付け、両方を使用して得られた証拠とともに問題を報告します。これらの問題は、盤石な発見と見なされ、"確信"と報告されます。静的分析だけで潜在的な問題を検出した場合は、報告された問題の信頼度を下げます。JavaScript解析に対するこの統合されたアプローチは、最も重要な問題を見つけるために結果をレビューするテスターを大いに支援します。
        </p>
        <h2 id="handling-application-errors">アプリケーションエラーの処理</h2>
        <p>
            Webアプリケーションの完全な診断は侵入的な手法であり、スキャンの進行中に接続障害、送信タイムアウト、バックエンドコンポーネントの停止などの問題が発生することがよくあります。さらに、Webアプリケーションファイアウォールのような防御機能は、特定のペイロードや、特定のパラメータ値の予期しない値に基づいて、特定の接続を切断する可能性があります。
        </p>
        <p>
            診断プロセス中、Burpはエラー状態の発生を可能な限り詳細に追跡します。個々のアクションでエラーが発生した場合、Burpはそのアクションを失敗としてマークし、次のアクションに移動します。必要に応じて、同じレベルのアクティビティーで繰り返しアクションが失敗すると、そのレベル全体が失敗とマークされます。したがってBurpは、個々の診断チェック、個々の挿入ポイント、診断するリクエスト全体、最終的にはスキャン全体と、徐々に失敗をマークしていきます。
        </p>
        <p>
            特定の診断リクエストで個別のエラーが発生するのは一般的であるため、Burpはまずエラーの詳細を取得してスキャンを続行します。診断がすべてしたとき、失敗した操作を再試行するために何回か追加確認も実行できます。特定のアプリケーションコンポーネント(バックエンドのデータベースなど)でスキャンの一部に問題が発生した場合に便利です。大量のエラーが発生した場合はスキャンの一時停止または中止もでき、ユーザは問題を調査しアプリケーションが安定してからスキャンを再開または再実行ができます。
        </p>
    </div>
</section>
</body>
</html>