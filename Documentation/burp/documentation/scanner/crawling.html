<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../assets/ps/styles/psselfservice.css">
<cms page-layout="FREESTYLE"></cms>
</head>
<body class="section theme-white wrapper-themed">
<section class="container ps-breadcrumbs">
    <ol class="breadcrumb-list">
        <li>
            <a href="https://portswigger.net/support">サポートセンタ</a>
        </li>
        <li>
            <a href="../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="index.html">Scanner</a>
        </li>
        <li>
            <a href="crawling.html">クロール</a>
        </li>
    </ol>
</section>
<section class="container labels-editions-wrapper">
    <label class="label-edition is-enterprise">Enterprise</label>
    <label class="label-edition is-professional">Professional</label>
</section>
<h1>クロール</h1>
<p>
    スキャンのクロールフェーズでは、アプリケーションを巡回し、リンクをたどり、フォームを送信し、必要な場合はログインし、アプリケーションのコンテンツとナビゲーション経路を列挙します。この一見単純な作業により、Burpのクローラがアクセスできるさまざまな課題点を提示し、アプリケーションの正確なマップを作成します。
</p>
<h2 id="core-approach">主な手法</h2>
<p>
    Burpのクローラはデフォルトで、Burpブラウザを使用して対象アプリケーション内を遷移し、リンクをクリックして、可能な場合は入力を送信します。アプリケーションのコンテンツや機能について、アプリケーションの異なる場所とそれらの間のリンクを表す、有向グラフ形式のマッピングを構築します。
</p>
<img src="../images/crawling/crawling-1.svg" alt="アプリケーション内の場所とそれらの間のリンクを表す有向グラフ">
<p>
    クローラは、アプリケーションが使用するURL構造は考慮しません。場所とは、到達したアイテムのURLではなく、コンテンツに基づいて識別(かつ後で再識別)されます。これによりクローラは、CSRFトークンやキャッシュバスターなど一時的なデータをURLに含めるような最新のアプリケーションを確実に処理できます。毎回各リンクのURL全体が変更されても、クローラは正確なマップを作成します。
</p>
<img src="../images/crawling/crawling-2.svg" alt="毎回変わる一時的なURLを持ったアプリケーション">
<p>
    アプリケーションの状態やユーザの操作に基づき、異なる場所に同じURLを使用するアプリケーションでも、クローラが処理できます。
</p>
<img src="../images/crawling/crawling-3.svg" alt="アプリケーションの状態やユーザの操作に基づき、異なる機能に同じURLを使用するアプリケーション">
<p>
    クローラが巡回して対象アプリケーションを網羅すると、まだ完了していないグラフの先端を追跡します。これらは、アプリケーションで観察されたがまだ訪問していないリンク(または他のナビゲーション遷移)のリンクを表しています。しかしクローラは、保留中のリンクに"ジャンプ"したり、コンテキストを外れてアクセスはしません。代わりに、現在の場所から直接ナビゲートするか、開始場所に戻ってからナビゲートします。通常のユーザがWebサイトをブラウズするアクションを、可能な限り忠実に再現します:
</p>
<img src="../images/crawling/crawling-4.svg" alt="クロールの開始位置に戻る">
<p>
    URL構造について考慮しない手法のクロールは、最近のWebアプリケーションを扱う際に非常に効果的ですが、"多すぎる"コンテンツにアクセスしてしまう可能性があります。最近のWebサイトにはよく、(ページフッターやバーガーメニューなど経由)で大量の余分なナビゲーション経路があり、つまりすべてが直接他のすべてにリンクされています。この問題に対処するためにBurpのクローラは、さまざまな手法を採用しています: 既にアクセスした場所へのリンクのフィンガープリントを作成して、重複アクセスを防ぎます; 新しいコンテンツの発見を優先させるよう幅を優先してクロールします; クロール範囲を制限し中断する設定ができます。これらの対処は、カレンダーのような"無限の"アプリケーションを正しく処理するためにも役立ちます。
</p>
<h2 id="session-handling">セッションハンドリング</h2>
<p>
    BurpのクローラはBurpブラウザを使用して対象アプリケーション内を遷移するため、最新のブラウザが実行できるほぼすべてのセッション管理メカニズムを自動的に処理できます。マクロを記録したり、セッションの取得方法や現在のセッションが有効か確認するセッションハンドリングルールを設定する必要はありません。
</p>
<p>
    クローラは、複数のクローラ"エージェント"を使用して作業を並列化します。各エージェントは、それぞれのブラウザでアプリケーションを巡回する、別々のユーザになります。各エージェントは独自のcookie jarを持ち、アプリケーションがcookieを発行すると更新されます。エージェントが開始位置に戻ってそこからクロールを開始する場合、cookie jarはクリアされ、完全に新しいブラウザセッションをシミュレートします。
</p>
<p>
    クローラが移動する際のリクエストは、先行するレスポンスに基づいて動的に生成されるため、URLまたはフォームフィールドのCSRFトークンは自動的に処理されます。よってクローラは、複雑なセッションハンドリングを使用する機能を正しくナビゲートでき、ユーザによる設定は不要です:
</p>
<img src="../images/crawling/crawling-5.svg" alt="クロール中にセッショントークンを自動的に処理する">
<h2 id="detecting-changes-in-application-state">アプリケーション状態の変化の検出</h2>
<p>
    最近のWebアプリケーションは非常にステートフルで、ユーザが実行したアクションの結果によって、同じアプリケーション機能が別のタイミングでは異なるコンテンツを返すのが一般的です。Burpのクローラは、クロール中に実行した操作に起因する、アプリケーション状態の変化を検出できます。
</p>
<p>
    次の例で、パス<code>BC</code>を移動すると、アプリケーションは状態1から状態2に遷移します。リンクDは、状態1と状態2では論理的に異なる位置になります。したがって、パス<code>AD</code>は空のカートに移動し、<code>ABCD</code>は入っている状態のカートに移動します。リンクDが不確定であるとするのではなく、リンクDが依存する状態変化の経路をクローラが認識できるということです。クローラは以後、入っているカートの場所に確実に到達し、そこから入手可能な他の機能にアクセスできます。
</p>
<img src="../images/crawling/crawling-6.svg" alt="クロール中のアプリケーション状態の変化の検出">
<h2 id="application-login">アプリケーションログイン</h2>
<p>
    Burpのクローラは、認証情報が送信されていない未認証フェーズから始まります。これが完了すると、Burpはアプリケーション内でログインと自己登録機能を検出します。
</p>
<p>
    アプリケーションが自己登録をサポートしている場合、Burpはユーザの登録を試みます。1つ以上の既存の認証情報を使用するようなクローラ設定もできます。
</p>
<p>
    その後、クローラは認証フェーズに進みます。何度かログイン機能にアクセスして、次を送信します:
</p>
<ul>
    <li>
        自己登録アカウントの認証情報 (あれば)
    </li>
    <li>
        設定された既存アカウントの認証情報
    </li>
    <li>
        偽の認証情報 (これらはアカウントリカバリーなど興味深い機能に到達するかもしれません)
    </li>
</ul>
<p>
    ログインに送信された各認証情報のセットごとに、Burpはログインの後に発見されたコンテンツをクロールします。これによりクローラは、さまざまなタイプのユーザが使用できる、さまざまな機能を取得できます。
</p>
<img src="../images/crawling/crawling-7.svg" alt="さまざまなログイン認証情報を使用してクロールし、まざまなユーザが利用できるさまざまな機能に到達する">
<h2 id="crawling-volatile-content">揮発性コンテンツのクロール</h2>
<p>
    最近のWebアプリケーションでは、"同じ"場所や機能がユーザの行動の結果によるものとは限らず、さまざまな場面で大幅に異なるレスポンスを返すような、揮発性のコンテンツが多くあります。ソーシャルメディアチャネルのフィードや、ユーザのコメント、インライン広告、または本当にランダムなコンテンツ(今日のメッセージ、A/Bテストなど)によって、この挙動が発生する可能性があります。
</p>
<p>
    Burpのクローラは、揮発性のコンテンツの多くの事例を識別し、異なるアクセスで異なるレスポンスであるにも関わらず、同じ場所を正しく再識別できます。これにより、一連のアプリケーションレスポンス内の"コア"要素に注目でき、これは興味深いアプリケーションのコンテンツと機能への主要なナビゲーション経路を発見する上で最も重要である可能性があります。
</p>
<img src="../images/crawling/crawling-9.svg" alt="HTMLページのコア要素と、さまざまな場面で変化するコンテンツの識別">
<p>
    場合によって、異なるタイミングで特定のリンクを訪問すると、"同じ"とみなすにはあまりにも異なるレスポンスが返ってくる場合があります。この状況では、Burpのクローラは2つの異なる場所としてレスポンスの両方のバージョンを取得し、グラフ内の不確定エッジとしてプロットします。アプリケーション全体の不確定な範囲がそれほど大きくない場合、Burpは関連するコンテンツをクロールでき、不確定リンクの背後にあるコンテンツへの道を確実に見つけられます:
</p>
<img src="../images/crawling/crawling-10.svg" alt="アプリケーションレスポンスが不確定になる場合のクロール">
<h2 id="crawling-with-burp-s-browser-browser-powered-scanning">Burpブラウザでのクロール (ブラウザを利用したスキャン)</h2>
<p>
    Burpはデフォルトで、マシンがそれをサポートしてそうな場合、対象Webサイトやアプリケーションのナビゲーションに<a href="../desktop/functions/burps-browser.html">Burpブラウザ</a>を使用します。このアプローチにはさまざまな大きな利点があり、最新のブラウザが持つクライアント側のテクノロジのほとんどをBurp Scannerが処理できるようになります。
</p>
<p>
    主な利点の1つは、JavaScriptを多用するコンテンツを効果的に巡回できることです。一部のWebサイトでは、JavaScriptを使用してナビゲーションUIを動的に生成しています。こういったコンテンツには生のHTMLが存在していませんが、Burp ScannerはBurpブラウザを使用してページを読み込み、UIの構築に必要なスクリプトを実行して、通常どおりクロールを続行できます。
</p>
<p>
    また、WebサイトがJavaScriptのイベントハンドラを使用してその場でリクエストを変更する場合でも、BurpブラウザのおかげでBurp Scannerが対応しています。クローラはこれらのイベントをトリガーし、関連するスクリプトを実行し、必要に応じてリクエストを変更します。たとえば、Webサイトが<code>onclick</code>イベント後にJavaScriptを使用し新しいCSRFトークンを生成し、後続のリクエストに追加する場合があります。JavaScriptイベントハンドラーによってクリック可能にされた要素を操作できます。
</p>
<p>
    必要に応じて、ブラウザを利用したスキャンを有効または無効にするよう手動でスキャン設定を変更できます。このオプションは、<strong>クロールオプション &gt; その他 &gt; <a href="../desktop/scanning/crawl-options.html#burp-s-browser-options">Burpブラウザオプション</a></strong>にあります。
</p>
</body>
</html>