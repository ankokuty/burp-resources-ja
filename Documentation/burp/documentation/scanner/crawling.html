<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../styles/css/ps.css">
</head>
<body>
<section class="container ps-breadcrumbs">
    <ol>
        <li>
            <a href="https://support.portswigger.net/">サポートセンター</a>
        </li>
        <li>
            <a href="../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="index.html">Scanner</a>
        </li>
        <li>
            <a href="crawling.html">クロール</a>
        </li>
    </ol>
</section>
<section class="container edition-labels">
    
    &nbsp;
    <span class="pro-edition-feature-label">プロフェッショナル</span>
</section>
<section class="maincontainer">
    <div class="container main">
        <h1>クロール</h1>
        <h2 id="core-approach">主な手法</h2>
        <p>
            Burpのクローラーは、ユーザーがブラウザで行うように、リンクをクリックし入力を送信して、アプリケーションの巡回を行います。アプリケーションのコンテンツや機能について、アプリケーションの異なる場所とそれらの間のリンクを表す、有向グラフ形式のマッピングを構築します。
        </p>
        <img src="../images/crawling/crawling-1.png" alt="">
        
        <p>
            クローラーは、アプリケーションが使用するURL構造は考慮しません。場所は、到達したアイテムのURLではなく、コンテンツに基づいて(そして後で再識別される)識別されます。これによりクローラーは、一時的なデータをURLに付与する、CSRFトークンやキャッシュバスターなどの最新のアプリケーションを確実に処理できます。毎回各リンクのURL全体が変更されても、クローラーは正確なマップを作成します。
        </p>
        <img src="../images/crawling/crawling-2.png" alt="">
        <p>
            同じURLを使用していても、アプリケーションの状態やユーザーとのやりとりに基づき異なる場所にアクセスするアプリケーションでも、クローラーが処理できます。
        </p>
        <img src="../images/crawling/crawling-3.png" alt="">
        <p>
            クローラーが巡回して対象アプリケーションを網羅すると、まだ完了していないグラフの先端を追跡します。これらは、アプリケーションで観察されたがまだ訪問していないリンク(または他のナビゲーション遷移)のリンクを表しています。しかしクローラーは、保留中のリンクに"ジャンプ"したり、コンテキストを外れてアクセスはしません。代わりに、現在の場所から直接ナビゲートするか、開始場所に戻ってからナビゲートします。通常のユーザーのアクションに、ブラウザを可能な限り近づけようとします。
        </p>
        <img src="../images/crawling/crawling-4.png" alt="">
        <p>
            URL構造について考慮しない手法のクロールは、最近のWebアプリケーションを扱う際に非常に効果的ですが、"多すぎる"コンテンツにアクセスしてしまう可能性があります。最近のウェブサイトにはよく、(ページフッターやバーガーメニューなど経由)で大量の余分なナビゲーション経路があり、つまり全てが直接他の全てにリンクされています。この問題に対処するためにBurpのクローラーは、さまざまな手法を採用しています: 既にアクセスした場所へのリンクのフィンガープリントを作成して、重複アクセスを防ぎます; 新しいコンテンツの発見を優先させるよう幅を優先してクロールします; クロール範囲を制限し中断する設定ができます。これらの対処は、カレンダーのような"無限の"アプリケーションを正しく処理するためにも役立ちます。
        </p>
        <h2 id="session-handling">セッションハンドリング </h2>
        <p>
            Burpのクローラーは、ユーザーがブラウザを使用した場合と同じ方法でターゲットアプリケーションを巡回し、ブラウザが処理できるほぼすべてのセッションハンドリングメカニズムで自動的に動作できます。マクロを記録したり、セッションの取得方法や現在のセッションが有効か確認するセッションハンドリングルールを設定する必要はありません。
        </p>
        <p>
            クローラーは、複数のクローラー"エージェント"を使用して作業を並列化します。各エージェントは、それぞれのブラウザでアプリケーションを巡回する、別々のユーザーになります。各エージェントは独自のcookie jarを持ち、アプリケーションがcookieを発行すると更新されます。エージェントが開始位置に戻ってそこからクロールを開始する場合、cookie jarはクリアされ、完全に新しいブラウザーセッションをシミュレートします。
        </p>
        <p>
            クローラーが移動する際のリクエストは、先行するレスポンスに基づいて動的に生成されるため、URLまたはフォームフィールドのCSRFトークンは自動的に処理されます。よってクローラーは、複雑なセッションハンドリングを使用する機能を正しくナビゲートでき、ユーザーによる設定は不要です:
        </p>
        <img src="../images/crawling/crawling-5.png" alt="">
        <h2 id="detecting-changes-in-application-state">アプリケーション状態の変化の検出</h2>
        <p>
            最近のWebアプリケーションは非常にステートフルで、ユーザーが実行したアクションの結果によって、同じアプリケーション機能が別のタイミングでは異なるコンテンツを返すのが一般的です。Burpのクローラーは、クロール中に実行した操作に起因する、アプリケーション状態の変化を検出できます。
        </p>
        <p>
            次の例で、パスBCを移動すると、アプリケーションは状態1から状態2に遷移します。リンクDは、状態1と状態2では論理的に異なる位置になります。したがって、パスADは空のカートに移動し、ABCDは入っている状態のカートに移動します。リンクDが非決定的であるとするのではなく、リンクDが依存する状態変化の経路をクローラーが認識できるということです。クローラーは以後、入っているカートの場所に確実に到達し、そこから入手可能な他の機能にアクセスができます。
        </p>
        <img src="../images/crawling/crawling-6.png" alt="">
        <h2 id="application-login">アプリケーションログイン</h2>
        <p>
            Burpのクローラーは、認証情報が送信されていない、未認証フェーズから始まります。これが完了すると、Burpはアプリケーション内でログインと自己登録機能を検出します。
        </p>
        <p>
            アプリケーションが自己登録をサポートしている場合、Burpはユーザーの登録を試みます。1つ以上の既存のログインを使用するよう、クローラーの設定もできます。
        </p>
        <p>
            その後、クローラーは認証フェーズに進みます。何度かログイン機能にアクセスして、次を送信します:
        </p>
        <ul>
            <li>
                自己登録アカウントの資格情報 (あれば)
            </li>
            <li>
                設定された既存アカウントの資格情報
            </li>
            <li>
                偽の資格情報 (これらはアカウントリカバリーなど興味深い機能に到達するかもしれません)
            </li>
        </ul>
        <p>
            ログインに送信された各資格情報のセットごとに、Burpはログインの後に発見されたコンテンツをクロールします。これによりクローラーは、さまざまなタイプのユーザーが使用できる、さまざまな機能を取得できます。
        </p>
        <img src="../images/crawling/crawling-7.png" alt="">
        <p>
            クローラーは通常、複数のクローラーエージェントを並行して使用しますが、一部のアプリケーションでは、同じユーザーによる同時ログインが禁止されています。ユーザーがログインするこの状況では、同じユーザーによって認証された既存のセッションはすべて終了します。Burpはこの挙動を検出でき、以後は個別のユーザーアカウントごとに1つの同時ログインのみを実行します。
        </p>
        <img src="../images/crawling/crawling-8.png" alt="">
        <h2 id="crawling-volatile-content">揮発性コンテンツのクロール</h2>
        <p>
            最近のWebアプリケーションにはよく揮発性コンテンツがあり、同じ場所や機能でも、ユーザーの行動に起因せず、異なるタイミングで実質的に異なるレスポンスを返します。ソーシャルメディアチャネルのフィードや、ユーザーのコメント、インライン広告、または本当にランダムなコンテンツ(今日のメッセージ、A/Bテストなど)などの要因によって、この挙動が発生する可能性があります。
        </p>
        <p>
            Burpのクローラーは、揮発性のコンテンツの多くの事例を識別し、異なるアクセスで異なるレスポンスであるにも関わらず、同じ場所を正しく再識別できます。これにより、一連のアプリケーションレスポンス内の"コア"要素に注目でき、これは興味深いアプリケーションのコンテンツと機能への主要なナビゲーション経路を発見する上で最も重要である可能性があります。
        </p>
        <img src="../images/crawling/crawling-9.png" alt="">
        <p>
            場合によって、異なるタイミングで特定のリンクを訪問すると、"同じ"とみなすにはあまりにも異なるレスポンスが返ってくる場合があります。この状況では、Burpのクローラーは2つの異なる場所としてレスポンスの両方のバージョンを取得し、グラフ内の非確定的なエッジとしてプロットします。アプリケーション全体の非決定的な範囲がそれほど大きくない場合、Burpは関連するコンテンツをクロールでき、非決定的リンクの背後にあるコンテンツへの道を確実に見つけられます:
        </p>
        <img src="../images/crawling/crawling-10.png" alt="">    </div>
</section>
</body>
</html>