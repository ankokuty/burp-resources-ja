<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../../../assets/ps/styles/psselfservice.css">
<cms page-layout="FREESTYLE"></cms>
</head>
<body class="section theme-white wrapper-themed">
<section class="container ps-breadcrumbs">
    <ol class="breadcrumb-list">
        <li>
            <a href="https://portswigger.net/support">サポートセンタ</a>
        </li>
        <li>
            <a href="../../../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="../../index.html">デスクトップ版</a>
        </li>
        <li>
            <a href="../index.html">ツール</a>
        </li>
        <li>
            <a href="index.html">Proxy</a>
        </li>
        <li>
            <a href="proxy-options.html">Burp Proxyオプション</a>
        </li>
    </ol>
</section>
<section class="container labels-editions-wrapper">
    <label class="label-edition is-professional">Professional</label>
    <label class="label-edition is-community">Community</label>
</section>
<h1>Burp Proxyオプション</h1>
<p>
    <strong>オプション</strong>タブには、Burp Proxyの設定があります:
</p>
<h2 id="proxy-listeners">Proxyリスナー</h2>
<p>
    Proxyリスナーは、ブラウザからの接続を待ち受けるローカルHTTPプロキシサーバです。すべてのリクエストとレスポンスを監視し、インターセプトできます。
</p>
<p>
    Burpはデフォルトで、ループバックインタフェースのポート8080でリスナーを1つだけ作成します。Burpブラウザでデフォルトのリスナーを使用して、ブラウザベースのほぼすべてのWebアプリケーションをテストできます。
</p>
<p>
    複数のProxyリスナーを作成でき、それらの挙動を制御する豊富な設定オプションがあります。特殊なアプリケーションのテストや、ブラウザベースではないHTTPクライアントを使ったテストをする際、これらのオプションを使う必要があるかもしれません。
</p>
<p>
    設定オプションにアクセスするには:
</p>
<ol>
    <li>
        リスナーを選択します。
    </li>
    <li>
        <strong>編集</strong>をクリックすると、<strong>プロキシリスナーの編集</strong>メニューが開きます。
    </li>
    <li>
        該当するオプションのタブに移動します。
    </li>
</ol>
<p>
    次のオプションタブがあります:
</p>
<h3 id="binding">バインド</h3>
<p>
    <strong>バインド</strong>タブでは、Proxyリスナーをローカルネットワークインタフェースにどのようにバインドするか制御します:
</p>
<ul>
    <li>
        <strong>バインドするポート</strong> - 接続の受信用に開かれるローカルインタフェースのポートです。別のアプリケーションによってバインドされていない空きポートを使用する必要があります。
    </li>
    <li>
        <p>
            <strong>バインドするアドレス</strong> - バインドするローカルインタフェースのIPアドレスです。次のインタフェースにバインドできます:
        </p>
        <ul>
            <li>
                ループバックインタフェースのみ。
            </li>
            <li>
                すべてのインタフェース。
            </li>
            <li>
                指定したローカルIPアドレス。
            </li>
        </ul>
    </li>
</ul>
<div class="highlightedarea">
    <h4>注</h4>
    <p>
        すべてのインタフェース、あるいはループバック以外の特定のインタフェースにリスナーをバインドすると、他のコンピュータがそのリスナーに接続できるようになります。
    </p>
</div>
<h3 id="request-handling">リクエストハンドリング</h3>
<p>
    <strong>リクエストハンドリング</strong>タブは、リスナーが受信したリクエストをリダイレクトするかどうかを制御します。:
</p>
<ul>
    <li>
        <strong>リダイレクト先ホスト</strong> - ブラウザがリクエストした対象に関わらず、すべてのリクエストを指定したホストに転送します。このオプションを使用する場合、検索/置換ルールを設定してリクエストのHostヘッダーを書き換える必要があるかもしれません。これは、リクエストをリダイレクトするサーバが、ブラウザが送信したHostヘッダとは異なるHostヘッダを期待している場合に必要です。
    </li>
    <li>
        <strong>リダイレクト先ポート</strong> - ブラウザが要求した対象に関わらず、すべてのリクエストを指定したポートに転送します。
    </li>
    <li>
        <strong>TLSを強制利用</strong> - 受信したリクエストが平文のHTTPでも、すべての送信接続にHTTPSを使うよう強制します。sslstripのような攻撃を行うには、このオプションとTLS関連のレスポンス変更オプションを併用します。これは、無意識のうちにトラフィックをBurpにプロキシされている被害者に対して、HTTPSを強制するアプリケーションを平文のHTTPにダウングレードさせる攻撃です。
    </li>
</ul>
<p>
    リダイレクトオプションは、それぞれ独立して使用できます。たとえば、リクエストのポートとプロトコルは維持しつつ、特定のホストにすべてのリクエストをリダイレクトできます。
</p>
<p>
    <strong>透過プロキシ</strong>は、プロキシ非対応のクライアントが直接リスナーに接続できます。詳細は、<a href="invisible.html">透過プロキシ</a>を参照してください。
</p>
<h3 id="certificate">証明書</h3>
<p>
    <strong>証明書</strong>タブは、TLSクライアントに提示されるTLSサーバ証明書を制御します。これらのオプションを使用すると、プロキシでインターセプトする際に発生するTLSに関するいくつかの問題を解決できます:
</p>
<ul>
    <li>
        ブラウザのTLS警告や、TLS例外を作成する必要がなくなります。
    </li>
    <li>
        WebページがTLSで保護されたアイテムを他のドメインから読み込んでいる箇所で、各参照ドメインのプロキシのTLS証明書を最初に手動で承諾しなくても、正しくブラウザに読み込まれるようになります。
    </li>
    <li>
        無効なTLS証明書を受信した場合、サーバへの接続を拒否するようなファットクライアントアプリケーションでも作業できます。
    </li>
</ul>
<p>
    次のオプションがあります:
</p>
<ul>
    <li>
        <strong>自己署名の証明書を使用する</strong> - 単純な自己署名TLS証明書がブラウザに提示され、常にTLS警告が起こります。
    </li>
    <li>
        <strong>CAが署名したホストごとの証明書を生成する</strong> - これがデフォルトオプションです。インストール時に、Burpは独自の自己署名の認証局(CA)を作成し、それをコンピュータ内に格納しておき、Burpを実行するたびにこれを使用します。ブラウザが特定のホストにTLS接続すると、Burpはそのホスト用のTLS証明書を生成し、CA証明書で署名します。ブラウザの信頼するルートに<a href="../../external-browser-config/certificate/index.html">BurpのCA証明書をインストール</a>すると、ホストごとの証明書は警告なしに受け入れられます。CA証明書をエクスポートして、他のツールやBurpの他のインスタンスでも使用できます。
    </li>
    <li>
        <strong>CAが署名した指定したホスト名の証明書を生成する</strong> - 指定したホスト名の証明書を1つだけ生成し、すべてのTLS接続で使います。透過プロキシを使う場合に、このオプションが必要かもしれません - クライアントはCONNECTリクエストを送信しないため、BurpはTLSネゴシエーションをする前に必要なホスト名を特定できません。<a href="../../external-browser-config/certificate/index.html">BurpのCA証明書</a>を信頼するルートとしてインストールできます。
    </li>
    <li>
        <strong>カスタム証明書を使用する</strong> - 指定した証明書(PKCS#12形式)を読み込み、ブラウザに提示します。これは<code>.p12</code>ファイル拡張子が必要なことに注意してください; <code>.psx</code>フォーマットの証明書はサポートしていません。たとえば指定したシリアル番号や証明書チェーンの証明書など、特定のサーバ証明書を必要とするクライアントを使用する場合、このオプションを使用します。
    </li>
</ul>
<p>
    CA証明書のインポート、エクスポート、生成については、<a href="manage-certificates.html">CA証明書の管理</a>を参照してください。
</p>
<h3 cms-ignore-validation="HEADING_CAPITALIZATION" id="tls-protocols">TLSプロトコル</h3>
<p>
    BurpがブラウザとTLSネゴシエーションを実行するときに使う、TLSプロトコルを制御します。Javaのデフォルトのプロトコルを使うようにもできますし、これらのデフォルト値を上書きしてカスタムプロトコルも有効にできます。
</p>
<h3 id="http">HTTP</h3>
<p>
    ProxyリスナーがクライアントにHTTP/2を使用させるかどうかを制御します。デフォルトで有効になっています。
</p>
<p>
    まれなケースで、たとえばクライアントのHTTP/2実装に問題がある場合などは、無効にしたいことがあります。
</p>
<p>
    この設定は、Burpとサーバ間の接続を変更するものではありません。Burpとサーバ間の接続を変更する方法は、<a href="../../settings/network/http.html#http-2">HTTP設定</a>を参照してください。
</p>
<h2 cms-ignore-validation="HEADING_CAPITALIZATION" id="intercepting-http-requests-and-responses">HTTPリクエストとレスポンスのインターセプト</h2>
<p>
    <a href="intercept-messages.html">Intercept</a>タブでどのリクエストとレスポンスを止めて表示や編集をするか制御します。リクエストとレスポンスには別々の設定が適用されます。
</p>
<p>
    <strong>インターセプト</strong>チェックボックスは、任意のメッセージをインターセプトするかどうかを決定します。チェックされている場合、設定されたルールを適用して各メッセージをインターセプトするべきかどうか判断します。
</p>
<p>
    各ルールの左側にあるチェックボックスで、有効と無効を切り替えます。ボタンを使用して、ルールの追加、編集、削除、並べ替えができます。
</p>
<p>
    次のように、メッセージのほぼすべての属性についてルールを設定できます:
</p>
<ul>
    <li>
        ドメイン名。
    </li>
    <li>
        IPアドレス。
    </li>
    <li>
        プロトコル。
    </li>
    <li>
        HTTPメソッド。
    </li>
    <li>
        URL。
    </li>
    <li>
        ファイル拡張子。
    </li>
    <li>
        パラメータ。
    </li>
    <li>
        cookie。
    </li>
    <li>
        ヘッダ/ボディコンテンツ。
    </li>
    <li>
        ステータスコード。
    </li>
    <li>
        MIMEタイプ。
    </li>
    <li>
        HTMLページタイトル。
    </li>
    <li>
        Proxyリスナーポート。
    </li>
</ul>
<p>
    ターゲットスコープ内にあるURLのみインターセプトするルールを設定できます。正規表現を使用して、属性ごとに複雑な条件を定義できます。
</p>
<p>
    ルールは順番に処理され、ブール型のANDやOR演算子を使用して結合されます。各演算子のスコープは次のように単純な"左から右"ロジックで処理されます:
</p>
<code class="code-scrollable">(以前のルールの累積的な結果) AND/OR (現在のルールの結果)</code><p>
    各メッセージですべての有効なルールが処理されます。最後の有効なルールが適用された結果によって、メッセージをインターセプトするか、またはバックグラウンドに転送するか決定します。
</p>
<p>
    <strong>Content-Lengthヘッダを自動的に更新する</strong>チェックボックスは、ユーザがメッセージを変更した場合にBurpが自動的にContent-Lengthヘッダを更新するかどうか制御します。このオプションは通常、HTTPボディが変更されたとき不可欠です。
</p>
<p>
    リクエストに対して、リクエスト最後の空行の過不足を自動的に修正するオプションがあります。リクエストの編集時にヘッダの後に空行がない場合、Burpが追加します。編集されたリクエストで、URLエンコードされたパラメータのボディの末尾に空行があった場合、Burpはこれらを削除します。インターセプトビューで手動で編集したリクエストの間違いを修正するのに便利で、無効なリクエストがサーバに発行されないようにできます。
</p>
<h2 cms-ignore-validation="HEADING_CAPITALIZATION" id="intercept-websocket-messages">WebSocketメッセージのインターセプト</h2>
<p>
    どのWebSocketメッセージを、インターセプトタブで止めて表示や編集するか制御します。
</p>
<p>
    送信(クライアントからサーバ)メッセージと受信(サーバからクライアント)メッセージをインターセプトするか、それぞれ個別に設定できます。
</p>
<h2 cms-ignore-validation="HEADING_CAPITALIZATION" id="response-modification">レスポンス変更</h2>
<p>
    レスポンスの自動変更を設定できます。アプリケーションレスポンスのHTMLを自動的に書き換えるとさまざまなタスクを達成できます。
</p>
<p>
    次のオプションは、データ上のクライアント側のコントロールを除去するのに便利かもしれません:
</p>
<ul>
    <li>
        <strong>hiddenフィールドを強制表示する</strong>。識別しやすいように、<strong>強制表示フィールドを強調表示</strong>するサブオプションがあります。
    </li>
    <li>
        <strong>無効化されたフォームフィールドを有効化する</strong>。
    </li>
    <li>
        <strong>入力フィールドの長さ制限を削除する</strong>。
    </li>
    <li>
        <strong>JavaScriptのフォーム検証を削除する</strong>。
    </li>
</ul>
<p>
    次のオプションを使用すると、クライアント側のロジックをテスト用に無効化できます。これらの機能はNoScriptのようなセキュリティ保護のために設計されているわけではないことに注意してください:
</p>
<ul>
    <li>
        <strong>すべてのJavaScriptを除去する</strong>。
    </li>
    <li>
        <strong>&lt;object&gt;タグを除去する</strong>。
    </li>
</ul>
<p>
    次のオプションを使用すると、トラフィックが無意識のうちにBurpにプロキシされてしまっている被害者ユーザに対して、SSLstripのような攻撃を行えます。リスナーオプションと組み合わせて使用し、発信方向のリクエストでTLSを強制すると、ユーザの接続からTLSを効果的に削除できます:
</p>
<ul>
    <li>
        <strong>HTTPSリンクをHTTPに変換する</strong>。
    </li>
    <li>
        <strong>cookieからsecure属性を削除する</strong>。
    </li>
</ul>
<h2 cms-ignore-validation="HEADING_CAPITALIZATION" id="match-and-replace">検索と置換</h2>
<p>
    <strong>検索と置換</strong>ルールを使用すると、Proxyを通過するリクエストとレスポンスを自動的に置換できます。HTTPメッセージごとに、有効な検索と置換ルールを順番に実行し、該当する置換を行います。
</p>
<p>
    ルールはリクエストとレスポンス、メッセージヘッダとボディ、そしてリクエスト最初の特別な行について、個別に定義できます。各ルールに対して、一致させるリテラル文字列か正規表現パターンと、置換する文字列を指定できます。
</p>
<p>
    メッセージヘッダの場合、ヘッダ行全体に一致する条件が指定されていて、置換文字列が空白の場合、そのヘッダは削除されます。検索文字列に空の文字列を指定した場合、置換文字列が新たなヘッダとして追加されます。
</p>
<p>
    一般的なタスクを支援するために、さまざまなデフォルトルールがあります。これらは、デフォルトで無効になっています。
</p>
<h3 id="matching-multi-line-regions">複数行範囲への一致</h3>
<p>
    メッセージボディの複数行部分にマッチする標準的な正規表現構文を使用できます。たとえば、レスポンスボディが次のみの場合:
</p>
<code class="code-scrollable">Now is the time for all good men to come to the aid of the party</code><p>
    次の正規表現を使用すると:
</p>
<code>Now.*the</code><p>
    次にマッチします:
</p>
<code class="code-scrollable">Now is the time for all good men to come to the aid of the</code><p>
    もし行内のみにマッチさせたい場合、正規表現を次の通り変更すると:
</p>
<code>Now[^\n]*the</code><p>
    次にマッチします:
</p>
<code>Now is the</code>
<h3 id="using-regex-groups-in-back-references-and-replacement-strings">前方参照と置換文字列で正規表現グループを使用する</h3>
<p>
    検索文字列の中で括弧を使用してグループを定義でき、左から右に順番に1 から始まるインデックス番号が割り当てられています(0は一致したグループ全体を表します)。
</p>
<p>
    グループはバックスラッシュとグループインデックスを使って、同じ一致文字列を前方参照できます。たとえば、間に他のタグを挟まない、開始と終了タグのペアにマッチするには、次の正規表現を使用します:
</p>
<code>&lt;([^/]\w*)[^&gt;]*&gt;[^&gt;]*?&lt;/\1[^&gt;]*&gt;</code><p>
    置換文字列で、$とグループインデックスを使って、グループを参照できます。次の置換文字列には、上記の正規表現に一致したタグの名前が含まれます:
</p>
<code>Replaced: $1</code>
<h2 cms-ignore-validation="HEADING_CAPITALIZATION" id="tls-pass-through">TLSパススルー</h2>
<p>
    TLS接続を直接通過させる宛先Webサーバを指定する場合に使用します。これらの接続によるリクエストやレスポンスは、Proxyの<a href="intercept-messages.html">インターセプトビュー</a>や履歴で詳細が利用できません。
</p>
<p>
    <strong>TLS接続のパススルー</strong>は、TLS証明書をピニングしているモバイルアプリケーションなど、クライアントでのTLSエラーの除去が難しい場合に便利です。アプリケーションが複数のドメインにアクセスする、またはHTTPとHTTPSが混在している場合、問題のあるホストへのTLS接続をパススルーに指定すると、他のトラフィックはBurpを使った通常の方法で作業できるようになります。
</p>
<p>
    <strong>クライアントがTLS接続に失敗したエントリを自動的に追加する</strong>を有効にすると、クライアントがTLSネゴシエーションに失敗したときにBurpが検出します。たとえば、Burpの<a href="../../external-browser-config/certificate/index.html">CA証明書</a>が認識されない場合などです。この場合、Burpは自動的にそのサーバをTLSパススルーリストに追加します。
</p>
<h2 id="miscellaneous">その他</h2>
<p>
    <strong>その他</strong>セクションで、次のオプションにアクセスできます:
</p>
<ul>
    <li>
        <strong>サーバへのリクエストにHTTP/1.0を使用する</strong> -  対象サーバへのリクエストでHTTPバージョン1.0を適用するかどうか制御します。デフォルト設定は、ブラウザが使うHTTPのバージョンを使用します。ただし、一部の古いサーバやアプリケーションは正常に機能するためにバージョン1.0を要求する場合があります。
    </li>
    <li>
        <strong>クライアントへのレスポンスにHTTP/1.0を使用する</strong> - 最近のブラウザはすべて、HTTPバージョン1.0と1.1を両方サポートしています。バージョン1.0には機能が少ないため、HTTPパイプラインの実行を防止するなどブラウザの機能を制御する場合に、バージョン1.0を強制的に使うと便利な場合があります。
    </li>
    <li>
        <strong>レスポンスヘッダに"Connection: close"をセットする</strong> - 一部の状況でHTTPパイプライン処理を防ぐために便利です。
    </li>
    <li>
        <strong>受信リクエストに"Connection: close"をセットする</strong> - 一部の状況でHTTPパイプライン処理を防ぐために便利です。
    </li>
    <li>
        <strong>受信リクエストから Proxy-*ヘッダを除去する</strong> - ブラウザが、プロキシサーバの情報をリクエストヘッダに含めて送信する場合があります。一部の攻撃では悪意のあるWebサイトを利用して、これらのヘッダにブラウザが機密データを含めるように誘導します。デフォルトで、受信したリクエストからこれらのヘッダを取り除き、すべての情報漏洩を防ぎます。このオプションをオフにすると、これらのヘッダは未変更のまま残ります。
    </li>
    <li>
        <strong>受信リクエストのAccept-Encodingヘッダからサポートしていないエンコーディングを削除する</strong> - ブラウザには通常、さまざまなレスポンスのエンコーディングを受け入れる機能があります。Burpでレスポンスを処理する際に、一部のエンコーディングが問題となる場合があります。Burpはデフォルトで、これらのエンコーディングが使用される機会を減らすために、サポートしていないエンコーディングを削除します。サポートしていないエンコーディングのサポートをサーバが要求する場合は、このオプションをオフにする必要があります。
    </li>
    <li>
        <strong>受信リクエストからSec-WebSocket-Extensionsヘッダを除去する</strong> - WebSocket接続に関するさまざまな拡張をサポートするブラウザがあります。Burpでレスポンスを処理する際に、一部のエンコーディングが問題となる場合があります。Burpはデフォルトで、拡張が使用される機会を減らすためにこのヘッダを削除します。サーバが特定の拡張を要求する場合は、このオプションをオフにする必要があります。
    </li>
    <li>
        <strong>リクエストのgzip/deflateを展開する</strong> - 一部のアプリケーション(多くの場合カスタムクライアントコンポーネントを使用している)が、リクエストのメッセージボディを圧縮します。このオプションは、圧縮されたリクエストボディを自動的に展開するかどうか制御します。圧縮されたボディを期待しているのにBurpがそれを除去するため、一部のアプリケーションが壊れる可能性があることに注意してください。
    </li>
    <li>
        <strong>レスポンスのgzip/deflateを展開する</strong> - ほとんどのブラウザは、gzip- または deflate-圧縮されたレスポンスのコンテンツを許容します。このオプションは、圧縮されたレスポンスボディを自動的に展開するか制御します。リクエストからAccept-Encodingヘッダを削除(Burp Proxyの<a href="#match-and-replace">検索と置換</a>機能で可能)すると、レスポンスの圧縮をほぼ防げます。
    </li>
    <li>
        <strong>http://burpsuite のWebインタフェースを無効にする</strong> - 保護されていないインタフェースからの接続を許可するように<a href="#binding">リスナー</a>を設定しなければならない状況で、他者からのブラウザ内インタフェースへのアクセスを防御したい場合に、このオプションが便利です。
    </li>
    <li>
        <strong>ブラウザへのBurpエラーメッセージを抑制する</strong> - 特定のエラーが発生した場合、Burpはデフォルトで意味のあるエラーメッセージをブラウザに返します。Burpをステルスモードで実行し、脆弱な被害者に中間者攻撃を実行したい場合は、これらのエラーメッセージの抑制が有効かもしれません。
    </li>
    <li>
        <strong>Proxy履歴やライブタスクにアイテムを送信しない</strong> - すべてのリクエストについて、Proxy履歴へのログ出力や、ライブタスクに送信されないようにするオプションです。特定のタスクで、ログ出力によるメモリやストレージの負荷を抑えたい場合に便利です。たとえば上位サーバへの認証や、検索と置換で使っている場合などです。
    </li>
    <li>
        <strong>スコープ外の場合、Proxy履歴やライブタスクにアイテムを送信しない</strong> - スコープ外のリクエストについて、Proxy履歴へのログ出力や、クロールやライブ診断などのライブタスクに送信されないようにするオプションです。スコープ外アイテムをプロジェクトデータに蓄積させないために便利です。
    </li>
</ul>
</body>
</html>