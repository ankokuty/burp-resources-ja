<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../../../../styles/css/ps.css">
</head>
<body>
<section class="container ps-breadcrumbs">
    <ol>
        <li>
            <a href="https://support.portswigger.net/">サポートセンター</a>
        </li>
        <li>
            <a href="../../../../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="../../../index.html">デスクトップ版</a>
        </li>
        <li>
            <a href="../../index.html">ツール</a>
        </li>
        <li>
            <a href="../index.html">Proxy</a>
        </li>
        <li>
            <a href="index.html">オプション</a>
        </li>
        <li>
            <a href="invisible.html">透過プロキシー</a>
        </li>
    </ol>
</section>
<section class="container edition-labels">
	<span class="pro-edition-feature-label">プロフェッショナル</span>&nbsp;<span class="pro-edition-feature-label">コミュニティ</span>
</section>
<section class="maincontainer">
    <div class="container main">
        <h1>Burp Proxy: 透過プロキシー</h1>
        <p>
            Burpの透過プロキシーサポートにより、プロキシー非対応クライアントが直接<a href="index.html#proxy-listeners">Proxyリスナー</a>に接続できるようになります。対象アプリケーションがブラウザ外で動作するシッククライアントコンポーネントを採用している場合や、ブラウザのフレームワーク外で独自のHTTPリクエストを行うブラウザプラグインの場合に、このオプションが便利な場合があります。多くの場合これらのクライアントは、HTTPプロキシーをサポートしていない、または使用するための簡単な設定方法を提供していません。
        </p>
        <h3>受信リクエストのリダイレクト</h3>
        <p>
            プロキシー非対応のクライアントを効果的にBurpに接続させるには、関連するホスト名のDNS名前解決を変更し、アプリケーションが使用するポートで透過プロキシーを設定しておきます。
        </p>
        <p>
            例えば、アプリケーションがexample.orgドメインを使い、HTTPとHTTPSを標準ポートで使っている場合、ローカルマシンにリダイレクトするようhostsファイルにエントリーを追加する必要があります:
        </p>
        <p class="InlineCode">
            
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 127.0.0.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; example.org&nbsp;
        
        </p>
        <p>
            リダイレクトされたリクエストを受信するには、透過Burp Proxyリスナーを127.0.0.1:80と127.0.0.1:443に作成する必要もあります。プロキシー非対応クライアントは、ドメイン名をローカルIPアドレスに名前解決し、そのインタフェースに直接リクエストを送信します。
        </p>
        <h3>透過プロキシーモード</h3>
        <p>
            DNSを使ってクライアントリクエストをローカルリスナーにリダイレクトするのは簡単ですが、そのリクエストはHTTPプロキシーが期待する通常形式のリクエストではないため、特別な透過プロキシーモードが必要になります。
        </p>
        <p>
            普通のHTTPを使っていた場合、プロキシースタイルのリクエストはこのようになります:
        </p>
            <p class="InlineCode">
                GET http://example.org/foo.php HTTP/1.1<br>Host: example.org
            </p>
        <p>
            一方、非プロキシースタイルのリクエストはこのようになります:
        </p>
            <p class="InlineCode">
                GET /foo.php HTTP/1.1<br>Host: example.org
            </p>
        <p>
            通常Webプロキシーは、どの宛先ホストへリクエストを転送するか判断するために、リクエストの先頭行で完全なURLを受信する必要があります(Hostヘッダーは宛先の決定に使われません)。透過プロキシーが有効な場合、Burpは非プロキシースタイルのリクエストを受信すると、Hostヘッダーの内容を解析して、そのリクエストの送信先として使います。
        </p>
        <p>
            プロキシーでHTTPSを使用するとき、クライアントは接続したい宛先ホストを特定するCONNECTリクエストを送信し、SSLネゴシエーションを実行します。しかしプロキシー非対応クライアントは、直接SSLネゴシエーションを実行し、宛先ホストと直接通信していると信じています。透過プロキシーが有効な場合、Burpはクライアントと直接SSLネゴシエーションを行い、復号したリクエストからHostヘッダーを解析します。
        </p>
        <h3>送信リクエストのリダイレクト</h3>
        <p>
            透過モードで実行している場合、Burpはデフォルトでそれぞれのリクエストから解析されたHostヘッダーの宛先ホストにリクエストを転送します。しかし、関連するドメインのエントリーをhostsファイルで変更していると、Burp自身もそのホスト名をローカルリスナーに名前解決してしまい、別の方法で設定しない限りリクエストが自分自身に転送され、無限ループが発生してしまいます。
        </p>
        <p>
            この問題を解決するためには 2 つの方法があります:
        </p>
        <ul>
            <li>
                全ての透過プロキシーのトラフィックが単一のドメインに向かう(つまりプロキシー非対応クライアントが単一のドメインとのみ通信する)場合、Proxyリスナーの<a href="index.html#request-handling">リダイレクトオプション</a>を使って、正しいIPアドレスにトラフィックが行くよう強制できます。
            </li>
            <li>
                プロキシーのトラフィックが複数のドメインに向かう場合、Burp自身の<a href="../../../options/connections.html#hostname-resolution">ホスト名解決オプション</a>を使って、各ドメインが正しいIPアドレスに戻るようhostsファイルを上書きできます。
            </li>
        </ul>
        <p>
            関連して、プロキシー非対応クライアントのリクエストにHostヘッダーが含まれていない場合に問題が発生します。このヘッダーがなく、非プロキシースタイルのリクエストを処理すると、どの宛先ホストにリクエストを転送すべきかBurpが判断できません。
        </p>
        <p>
            ここでも、この問題を解決するための 2 つの方法があります。全てのリクエストを同じ宛先ホストに転送する場合は、Proxyリスナーの<a href="index.html#request-handling">リダイレクトオプション</a>を使って、正しいIPアドレスにトラフィックが行くよう強制できます。
        </p>
        <p>
                異なるリクエストを異なるホストに転送する場合は、複数のProxyリスナーを使う必要があります:</p>
                <ul>
                    <li>
                        宛先ごとに個別の仮想ネットワークインタフェースを作成します。(ほとんどのオペレーティングシステムでは、ループバックのようなプロパティを持つ仮想インタフェースを追加で作成できます。また、仮想環境でも可能です。)
                    </li>
                    <li>
                        異なるインタフェースごとにProxyリスナーを１つ(またはHTTPとHTTPSの両方を使う場合は２つ)作成します。
                    </li>
                    <li>
                        hostsファイルを使い、それぞれの宛先ホスト名を異なるネットワークインタフェース(つまり異なるリスナー)にリダイレクトします。
                    </li>
                    <li>
                        各インタフェースのリスナーごとに、トラフィックをリダイレクトするホストのIPアドレスを設定します。
                    </li>
                </ul>
        <h3>SSL 証明書の処理</h3>
        <p>
            Burp Proxyリスナーで使用される<a href="index.html#certificate">サーバーSSL証明書</a>を設定する様々なオプションがあります。デフォルトオプションの宛先ホストごとに証明書を自動生成する設定は、透過プロキシーでは動かない場合があります。プロキシー非対応クライアントはリスナーと直接SSLネゴシエーションをし、CONNECTリクエストヘッダーを送信しないため、クライアントが接続しようとしている宛先ホストを特定できません。ブラウザを含む多くのクライアントはClient Helloメッセージの"server_name"拡張をサポートし、クライアントがネゴシエートしようとしている宛先ホストが識別できます。この拡張が存在している場合、Burpは通常通りそのホスト名を証明書の生成に使用します。しかし、Client Helloメッセージにその拡張がない場合は、Burpはフェイルオーバーとして静的な自己署名証明書を使用します。
        </p>
        <p>
            送信リクエストのリダイレクトを使って、この問題を解決する２つの方法があります:
        </p>
        <ul>
            <li>
                全てのHTTPSリクエストが同じドメインの場合、アプリケーションが使うホスト名を指定して、CA署名の証明書を生成するよう透過リスナーの設定ができます。
            </li>
            <li>
                HTTPリクエストが異なるドメインの場合、送信リクエストのリダイレクトで説明したように、それぞれの宛先ごとに、それぞれ異なる仮想ネットワークインタフェースを使った透過Proxyリスナーを作成する必要があります。それぞれのリスナーで、トラフィックをリダイレクトする先のホスト名を指定した、CA署名の証明書を生成する設定する必要があります。
            </li>
        </ul>
    </div>
</section>
</body>
</html>