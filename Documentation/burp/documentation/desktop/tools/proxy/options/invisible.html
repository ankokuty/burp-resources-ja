<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../../../../assets/ps/styles/psselfservice.css">
<cms page-layout="FREESTYLE"></cms>
</head>
<body class="section theme-white wrapper-themed">
<section class="container ps-breadcrumbs">
    <ol class="breadcrumb-list">
        <li>
            <a href="https://portswigger.net/support">サポートセンタ</a>
        </li>
        <li>
            <a href="../../../../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="../../../index.html">デスクトップ版</a>
        </li>
        <li>
            <a href="../../index.html">ツール</a>
        </li>
        <li>
            <a href="../index.html">Proxy</a>
        </li>
        <li>
            <a href="index.html">オプション</a>
        </li>
        <li>
            <a href="invisible.html">透過プロキシ</a>
        </li>
    </ol>
</section>
<section class="container labels-editions-wrapper">
    <label class="label-edition is-professional">Professional</label>
    <label class="label-edition is-community">Community</label>
</section>
<h1>Burp Proxy: 透過プロキシ</h1>
<p>
    Burpの透過プロキシサポートにより、プロキシ非対応クライアントが直接<a href="index.html#proxy-listeners">Proxyリスナー</a>に接続できるようになります。対象アプリケーションがブラウザ外で動作するシッククライアントコンポーネントを採用している場合や、ブラウザのフレームワーク外で独自のHTTPリクエストを行うブラウザプラグインの場合に、このオプションが便利な場合があります。多くの場合これらのクライアントは、HTTPプロキシをサポートしていない、または使用するための簡単な設定方法を提供していません。
</p>
<h3>受信リクエストのリダイレクト</h3>
<p>
    プロキシ非対応のクライアントを効果的にBurpに接続させるには、関連するホスト名のDNS名前解決を変更し、アプリケーションが使用するポートで透過プロキシを設定しておきます。
</p>
<p>
    たとえば、アプリケーションが<code>example.org</code>ドメインを使い、HTTPとHTTPSを標準ポートで使っている場合、ローカルマシンにリダイレクトするようhostsファイルにエントリを追加する必要があります:
</p>
<code class="code-scrollable"> 127.0.0.1 example.org </code><p>
    リダイレクトされたリクエストを受信するには、透過Burp Proxyリスナーを<code>127.0.0.1:80</code>と<code>127.0.0.1:443</code>に作成する必要もあります。プロキシ非対応クライアントは、ドメイン名をローカルIPアドレスに名前解決し、そのインタフェースに直接リクエストを送信します。
</p>
<h3>透過プロキシモード</h3>
<p>
    DNSを使ってクライアントリクエストをローカルリスナーにリダイレクトするのは簡単ですが、そのリクエストはHTTPプロキシが期待する通常形式のリクエストではないため、特別な透過プロキシモードが必要になります。
</p>
<p>
    普通のHTTPを使っていた場合、プロキシスタイルのリクエストはこのようになります:
</p>
<code class="code-scrollable">GET http://example.org/foo.php HTTP/1.1 Host: example.org</code><p>
    一方、非プロキシスタイルのリクエストはこのようになります:
</p>
<code class="code-scrollable">GET /foo.php HTTP/1.1 Host: example.org</code><p>
    通常Webプロキシは、どの宛先ホストへリクエストを転送するか判断するために、リクエストの先頭行で完全なURLを受信する必要があります(Hostヘッダは宛先の決定に使われません)。透過プロキシが有効な場合、Burpは非プロキシスタイルのリクエストを受信すると、Hostヘッダの内容を分析してそのリクエストの送信先として使います。
</p>
<p>
    プロキシでHTTPSを使用するとき、クライアントは接続したい宛先ホストを特定するCONNECTリクエストを送信し、TLSネゴシエーションを実行します。しかしプロキシ非対応クライアントは、直接TLSネゴシエーションを実行し、宛先ホストと直接通信していると信じています。透過プロキシが有効な場合、Burpはクライアントと直接TLSネゴシエーションを行い、復号したリクエストからHostヘッダを分析します。
</p>
<h3>送信リクエストのリダイレクト</h3>
<p>
    透過モードで実行している場合、Burpはデフォルトでそれぞれのリクエストから分析されたHostヘッダの宛先ホストにリクエストを転送します。しかし、関連するドメインのエントリをhostsファイルで変更していると、Burp自身もそのホスト名をローカルリスナーに名前解決してしまい、別の方法で設定しない限りリクエストが自分自身に転送され、無限ループが発生してしまいます。
</p>
<p>
    この問題を解決するためには 2 つの方法があります:
</p>
<ul>
    <li>
        すべての透過プロキシのトラフィックが単一のドメインに向かう(つまりプロキシ非対応クライアントが単一のドメインとのみ通信する)場合、Proxyリスナーの<a href="index.html#request-handling">リダイレクトオプション</a>を使って、正しいIPアドレスにトラフィックが行くよう強制させられます。
    </li>
    <li>
        プロキシのトラフィックが複数のドメインに向かう場合、Burp自身の<a href="../../../settings/network/connections.html#hostname-resolution-overrides">ホスト名解決オプション</a>を使って、各ドメインが正しいIPアドレスに戻るようhostsファイルを上書きできます。
    </li>
</ul>
<p>
    関連して、プロキシ非対応クライアントのリクエストにHostヘッダが含まれていない場合に問題が発生します。このヘッダがなく、非プロキシスタイルのリクエストを処理すると、どの宛先ホストにリクエストを転送すべきかBurpが判断できません。
</p>
<p>
    ここでも、この問題を解決するための 2 つの方法があります。すべてのリクエストを同じ宛先ホストに転送する場合は、Proxyリスナーの<a href="index.html#request-handling">リダイレクトオプション</a>を使って、正しいIPアドレスにトラフィックが行くよう強制させられます。
</p>
<p>
    異なるリクエストを異なるホストに転送する場合は、複数のProxyリスナーを使う必要があります:
</p>
<ul>
    <li>
        宛先ごとに個別の仮想ネットワークインタフェースを作成します。(ほとんどのオペレーティングシステムでは、ループバックのようなプロパティを持つ仮想インタフェースを追加で作成できます。また、仮想環境でも可能です。)
    </li>
    <li>
        異なるインタフェースごとにProxyリスナーを1つ(またはHTTPとHTTPSの両方を使う場合は2つ)作成します。
    </li>
    <li>
        hostsファイルを使い、それぞれの宛先ホスト名を異なるネットワークインタフェース(つまり異なるリスナー)にリダイレクトします。
    </li>
    <li>
        各インタフェースのリスナーごとに、トラフィックをリダイレクトするホストのIPアドレスを設定します。
    </li>
</ul>
<h3>TLS証明書の処理</h3>
<p>
    Burp Proxyリスナーで使用される<a href="index.html#certificate">サーバTLS証明書</a>を設定するさまざまなオプションがあります。デフォルトオプションの宛先ホストごとに証明書を自動生成する設定は、透過プロキシでは動かない場合があります。プロキシ非対応クライアントはリスナーと直接TLSネゴシエーションをし、CONNECTリクエストヘッダを送信しないため、クライアントが接続しようとしている宛先ホストを特定できません。ブラウザを含む多くのクライアントはClient Helloメッセージの"server_name"拡張をサポートし、クライアントがネゴシエートしようとしている宛先ホストが識別できます。この拡張が存在している場合、Burpは通常通りそのホスト名を証明書の生成に使用します。しかし、Client Helloメッセージにその拡張がない場合は、Burpはフェイルオーバーとして静的な自己署名証明書を使用します。
</p>
<p>
    送信リクエストのリダイレクトを使って、この問題を解決する2つの方法があります:
</p>
<ul>
    <li>
        すべてのHTTPSリクエストが同じドメインの場合、アプリケーションが使うホスト名を指定して、CA署名の証明書を生成するよう透過リスナーを設定できます。
    </li>
    <li>
        HTTPリクエストが異なるドメインの場合、送信リクエストのリダイレクトで説明したように、それぞれの宛先ごとに、それぞれ異なる仮想ネットワークインタフェースを使った透過Proxyリスナーを作成する必要があります。それぞれのリスナーで、トラフィックをリダイレクトする先のホスト名を指定した、CA署名の証明書を生成する設定する必要があります。
    </li>
</ul>
</body>
</html>