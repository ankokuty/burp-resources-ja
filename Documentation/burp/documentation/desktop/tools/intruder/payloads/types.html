<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../../../../assets/ps/styles/psselfservice.css">
<cms page-layout="FREESTYLE"></cms>
</head>
<body class="section theme-white wrapper-themed">
<section class="container ps-breadcrumbs">
    <ol class="breadcrumb-list">
        <li>
            <a href="https://portswigger.net/support">サポートセンタ</a>
        </li>
        <li>
            <a href="../../../../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="../../../index.html">デスクトップ版</a>
        </li>
        <li>
            <a href="../../index.html">ツール</a>
        </li>
        <li>
            <a href="../index.html">Intruder</a>
        </li>
        <li>
            <a href="index.html">ペイロード</a>
        </li>
        <li>
            <a href="types.html">種類</a>
        </li>
    </ol>
</section>
<section class="container labels-editions-wrapper">
    <label class="label-edition is-professional">Professional</label>
</section>
<h1>ペイロードタイプ</h1>
<p>
    Burp Intruderには次のペイロードタイプがあります:
</p>
<ul>
    <li>
        <a href="#simple-list">単純リスト</a>
    </li>
    <li>
        <a href="#runtime-file">実行時ファイル</a>
    </li>
    <li>
        <a href="#custom-iterator">カスタムイテレータ</a>
    </li>
    <li>
        <a href="#character-substitution">文字置換</a>
    </li>
    <li>
        <a href="#case-modification">大文字小文字変換</a>
    </li>
    <li>
        <a href="#recursive-grep">再帰検索</a>
    </li>
    <li>
        <a href="#illegal-unicode">不正なUnicode</a>
    </li>
    <li>
        <a href="#character-blocks">文字ブロック</a>
    </li>
    <li>
        <a href="#numbers">数値</a>
    </li>
    <li>
        <a href="#dates">日付</a>
    </li>
    <li>
        <a href="#brute-forcer">ブルートフォース</a>
    </li>
    <li>
        <a href="#null-payloads">ペイロードなし</a>
    </li>
    <li>
        <a href="#character-frobber">文字フロバー</a>
    </li>
    <li>
        <a href="#bit-flipper">ビットフリッパー</a>
    </li>
    <li>
        <a href="#username-generator">ユーザ名ジェネレータ</a>
    </li>
    <li>
        <a href="#ecb-block-shuffler">ECBブロックシャッフル</a>
    </li>
    <li>
        <a href="#extension-generated">拡張による生成</a>
    </li>
    <li>
        <a href="#copy-other-payload">他ペイロードコピー</a>
    </li>
</ul>
<h2 id="simple-list">単純リスト</h2>
<p>
    これは最も単純なペイロードタイプで、ペイロードとして使用される文字列の単純なリストを設定できます。
</p>
<p>
    テキストボックスと<strong>追加</strong>ボタンを使用してリストに追加するか、クリップボードからリストを貼り付けるか、ファイルからの読み込みができます。<strong>重複排除</strong>オプションは、リストから重複するエントリを削除します。これにより、送信されるリクエストの数が減り、攻撃の効率が向上します。
</p>
<h3 id="predefined-payload-lists">定義済みペイロードリスト</h3>
<p>
    <label class="label-edition is-professional">Professional</label>
    アイテムの一覧を指定するタイプのペイロードタイプでは、<strong>リストから追加</strong>ドロップダウンメニューが使用できます。一般的なユーザ名やパスワード、ファジング文字列など便利な定義済みリストを追加できます。Intruderメニューの<strong>定義済みペイロードリストを編集</strong>を使って、定義済みペイロードリストをカスタマイズできます。ペイロードファイルを含んだ独自のディレクトリが選択でき、カスタムディレクトリにBurpの組み込みペイロードリストをコピーして、編集もしくは独自のペイロードリストも使えます。
</p>
<p>
    選択したリストに<code>{KNOWNFILE}</code>や<code>{domain}</code>のようなプレースホルダが含まれている場合、Intruderのルールを設定しプレースホルダーを正しく処理する必要があります。
</p>
<p>
    設定するには: 
</p>
<ol>
    <li>
        Intruderの "ペイロード"タブに移動します。
    </li>
    <li>
        <strong>ペイロード処理</strong>まで下にスクロールし、<strong>追加</strong>を選択してルールを追加します。
    </li>
    <li>
        ルールタイプの入力を求められたら、<strong>検索/置換</strong>を選択します。
    </li>
    <li>
        <strong>検索正規表現</strong>ボックスに次のように入力します: <code>\{placeholder\}</code> (たとえば<code>\{KNOWNFILE\}</code>や<code>\{domain\}</code>)。
    </li>
    <li>
        <strong>置換</strong>ボックスに、置換するプレースホルダーを入力します(たとえば、<code>{KNOWNFILE}</code>の代わりにapplication.exe、<code>{domain}</code>の代わりにportswigger.netなど)。
    </li>
</ol>
<h2 id="runtime-file">実行時ファイル</h2>
<p>
    実行時にペイロード文字列を読み込むファイルを設定できます。とても大きなペイロードリストが必要で、リストをメモリに保持させたくない場合に便利です。ファイルの各行を1つのペイロードとして読み込むので、ペイロードには改行文字を含められません。
</p>
<h2 id="custom-iterator">カスタムイテレータ</h2>
<p>
    複数のアイテムリストを設定し、リスト内のアイテムすべてを組み合わせてペイロードを生成できます。指定されたテンプレートに従って、文字やその他のアイテムを組み合わせて、カスタマイズした文字列を生成できる強力な方法です。たとえば給与アプリケーションで、AB/12 という形式の個人番号で個人を特定してる場合、全員の詳細情報を取得するために、可能性のあるすべての個人番号を列挙する必要があります。
</p>
<p>
    カスタムイテレーターは、組み合わせの生成で使う最大8つの異なる<strong>ポジション</strong>を定義できます。各ポジションの定義はアイテムのリストです。追加で<strong>区切り</strong>文字列が設定でき、ポジションとその次の間に挿入されます。前述の例では、ポジション1と2のアイテムは「A」～「Z」、ポジション3と4のアイテムは「0」～「9」、そしてポジション2の区切り文字に「/」文字を設定します。攻撃を実行すると、各ポジションで各アイテムを反復処理し、すべての可能性のある組み合わせを網羅します。したがってこの例では、ペイロードの総数は 26×26×10×10になります。
</p>
<p>
    リストアイテムは<a href="#simple-list">シンプルリスト</a>ペイロードタイプと同じ方法で編集できます。<strong>すべてクリア</strong>ボタンは、カスタムイテレーターのすべてのポジションからすべての設定を削除します。
</p>
<p>
    <strong>定義済み形式を選択</strong>ドロップダウンメニューは、 あらかじめ設定されたカスタムイテレーターを選択できます。これらはさまざまな標準的な攻撃に使え、またはカスタマイズされた攻撃用に変更できます。使用可能なスキームは、URLの生成に使える<strong>ディレクトリ/ファイル.拡張子</strong>、パスワード推測攻撃で拡張単語リストの生成に使える<strong>パスワード+数値</strong>です。
</p>
<h2 id="character-substitution">文字置換</h2>
<p>
    文字列のリストと、各アイテムに適用するさまざまな文字置換が設定できます。パスワード推測攻撃で、辞書単語の一般的なバリエーションを生成するために便利な場合があります。
</p>
<p>
    置換する文字をUIで設定できます。攻撃を実行すると、設定されたアイテムそれぞれを順序通り処理していきます。各アイテムごとに、定義した文字置換の全組み合わせで置換した、大量のペイロードが生成されます。たとえば、デフォルトの置換ルール(e&gt;3とt&gt;7が入っています)で、"peter"は次のペイロードを生成します:
</p>
<code class="code-scrollable">peter p3ter pe7er p37er pet3r p3t3r pe73r p373r</code><p>
    リストアイテムは<a href="#simple-list">シンプルリスト</a>ペイロードタイプと同じ方法で編集できます。
</p>
<h2 id="case-modification">大文字小文字変換</h2>
<p>
    文字列のリストと、各アイテムに適用する大文字小文字の変更方法を設定できます。パスワード推測攻撃で、辞書単語の大文字小文字違いのバリエーションを生成するために便利な場合があります。
</p>
<p>
    次の大文字小文字変更規則を選択できます:
</p>
<ul>
    <li>
        <strong>変更なし</strong> - 変更しません。
    </li>
    <li>
        <strong>小文字に変換</strong> - アイテム内のすべての文字を小文字に変換します。
    </li>
    <li>
        <strong>大文字に変換</strong> - アイテム内のすべての文字を大文字に変換します。
    </li>
    <li>
        <strong>先頭のみ大文字でその他は小文字</strong> - アイテムの先頭文字を大文字に変換し、以降の文字は小文字に変換します。
    </li>
    <li>
        <strong>先頭のみ大文字でその他は変更なし</strong> - アイテムの先頭文字を大文字に変換し、以降の文字は変更しません。
    </li>
</ul>
<p>
    設定されたアイテムそれぞれを順序通り処理し、各アイテムの大文字小文字を調整します。重複するペイロードは破棄されます。たとえば、すべての変更オプションが選択されている場合、"Peter Wiener"は次のペイロードを生成します:
</p>
<code class="code-scrollable">Peter Wiener peter wiener PETER WIENER Peter wiener</code><p>
    リストアイテムは<a href="#simple-list">シンプルリスト</a>ペイロードタイプと同じ方法で編集できます。
</p>
<h2 id="recursive-grep">再帰検索</h2>
<p>
    このペイロードタイプは、前の攻撃リクエストのレスポンスからペイロードを抽出します。有用なデータの抽出やエクスプロイトの引き渡しを再帰的に行う必要があるような状況で便利です。
</p>
<p>
    このペイロードタイプは<a href="../options.html#grep-extract">抽出grep</a>機能と共に動作し、レスポンスから気になる情報を含む部分を抽出します。前の攻撃レスポンスから抽出したテキストが、次のペイロードとして使われます。
</p>
<p>
    これは、さまざまなタスクに使用できます。たとえば、フォームのクエリーで再帰的にSQLインジェクションを行い、データベースからの情報抽出が可能になりま
</p>
<code class="code-scrollable">union select name from sysobjects where name &gt; 'a'</code><p>
    サーバのエラーメッセージから、最初のデータベースオブジェクトの名前が漏洩しています:
</p>
<code class="code-scrollable">Syntax error converting the varchar value 'accounts' to a column of data type int.</code><p>
    このクエリーに次は'accounts'を使い、次のオブジェクトを特定します。再帰的にペイロードをgrepしてデータベースの全オブジェクトを一覧化する作業を、簡単に自動化できます。
</p>
<p>
    次のオプションを選択する必要があります:
</p>
<ul>
    <li>
        <strong>ペイロードを取得する抽出grepアイテム</strong> - ペイロードに利用される<a href="../options.html#grep-extract">抽出grep</a>アイテムです。
    </li>
    <li>
        <strong>最初のリクエストの初期ペイロード</strong> - 最初のリクエストのペイロードです(ペイロードに利用される事前のレスポンスがないため)。
    </li>
    <li>
        <strong>重複ペイロード検出時に停止</strong> - 連続して同じペイロードになった場合、攻撃を停止させます。これは通常、動作が完了したことを示します。
    </li>
</ul>
<div class="highlightedarea">
    <h4>注</h4>
    <p>
        このペイロードの性質上、最大同時リクエスト数を1にした<a href="../intruder-resource-pool.html">リソースプール</a>を使用する必要があります。
    </p>
</div>
<h2 id="illegal-unicode">不正なUnicode</h2>
<p>
    不正なUnicode表記の文字列を生成します。たとえばファイルパストラバーサル攻撃の防御で ../ と ..\ へのマッチを想定している場合など、特定の文字をブロックするよう設計されているフィルタの回避に効果がある場合があります。
</p>
<p>
    ペイロードタイプはアイテムのリストとして動作し、各アイテムの指定した文字を、不正なUnicodeエンコーディングの別の文字に置き換えることで、大量のペイロードを生成します。使用可能なオプションは次の通りです。
</p>
<h3>冗長なUTF-8エンコード</h3>
<p>
    Unicodeエンコーディング方式では、1つの文字を表すために最大6バイト使えます。基本的なASCII文字(0x00 - 0x7F)はそのまま1バイトで表されます。ただし、Unicodeではそれらを複数バイト("冗長な"エンコード)でも表現できます。このオプションでは、冗長なエンコーディングを使用するかどうか、また使用する場合はその最大サイズを設定します。
</p>
<h3>不正なUTF-8継続バイト</h3>
<p>
    冗長なUTF-8長で、2バイト以上を選択している場合に有効になります:
</p>
<ul>
    <li>
        <strong>不正なUTF-8</strong> - 文字が2バイト以上でエンコードされている場合、2バイト目以降は継続バイトであることを示すために、バイナリ形式で<code>10xxxxxx</code>である必要があります。ただし、1バイト目の最上位ビットを見れば継続バイト数が特定できるため、Unicodeデコードルーチンが継続バイトの最初の2ビットを無視する場合があります。これは各継続バイトを、バイナリ形式で<code>00xxxxxx</code>、<code>01xxxxxx</code>、<code>11xxxxxx</code>の3つに不正に変形できることを意味します。このオプションを選択すると、各継続バイトに3つのエンコーディングが追加で生成されます。
    </li>
    <li>
        <strong>マルチバイト文字の組み合わせ最大化</strong> - 冗長UTF-8長で3バイト以上を選択し、かつ<strong>不正なUTF-8</strong>が選択されている場合に有効になります。<strong>組み合わせ最大化</strong>オプションが選択されていない場合、Burpは各継続バイトを順番に不正な値に書き換えて不正な値を生成します; 各継続バイトごとに、3つの不正な値が生成され、他の継続バイトは変更されません。しかし、<strong>組み合わせの最大化</strong>オプションが選択された場合、継続バイトのすべての不正な値の組み合わせを生成します - すなわち複数の継続バイトが同時に変更されます。膨大な数のさまざまな不正なエンコーディングを生成するため、高度なパターンマッチ制御を回避する場合にこの機能が役立つかもしれません。
    </li>
</ul>
<h3>不正な16進数文字</h3>
<p>
    生成されたバイトシーケンスを16進数表記で表現する方法を制御します:
</p>
<ul>
    <li>
        <strong>不正な16進数表記</strong> - 冗長なエンコードと不正な継続バイト(選択している場合)を使用し、不正にエンコードされたアイテムのリストを生成する場合、結果のバイト列の16進数エンコードを変更してパターンマッチ制御を混乱させられます。16進数エンコードでは、10進数の10-15を表現するのに、「A」～「F」の文字を使います。しかし、一部の16進数デコーダーは、「G」を10進数の16、「H」を10進数の17などと解釈します。よって、<code>0x1G</code>は10進数の32と解釈されるかもしれません。そして、2桁の16進数コードの先頭にこの不正な16進数文字が使われると、デコードした結果1バイトの最大値をオーバフローしますが、この状況で一部の16進数デコーダは結果の最下位8ビットのみを使用します。よって、<code>0xG1</code>は10進数で257にデコードされ、10進数の1と解釈されます。上記のようにデコードされた場合に同じ16進数コードとして解釈される不正な16進数表現が、2桁の正常な16進数コードそれぞれに対して、4～6個あります。<strong>不正な16進数表記</strong>オプションが選択された場合、不正なエンコードをされたアイテムのリストそれぞれについて、あり得るすべての不正な16進数表記を生成します。
    </li>
    <li>
        <strong>マルチバイト文字の組み合わせ最大化</strong> - 冗長なUTF-8の最大長に2バイト以上が選択され、<strong>不正な16進数表記</strong>オプションが選択された場合に、このオプションが選択できます。<strong>組み合わせの最大化</strong>オプションが選択されていない場合、Burpは各バイトを順番に処理して不正な16進数を生成します; 各バイトごとに4～6個の16進数エンコードが生成され、そのほかのバイトは変更されません。しかし、<strong>組み合わせの最大化</strong>オプションが選択されると、すべてのバイトに対するすべての不正な16進数の組み合わせを生成します - すなわち複数のバイトが同時に変更されます。膨大な数のさまざまな不正なエンコーディングを生成するため、高度なパターンマッチ制御を回避する場合にこの機能が役立つかもしれません。
    </li>
</ul>
<h3>16進数フォーマット</h3>
<p>
    16進数でエンコードされたペイロードの見た目を制御します:
</p>
<ul>
    <li>
        <strong>英小文字使用</strong> - 16進数コードに小文字アルファベットを使用するか、大文字を使用するか決定します。
    </li>
    <li>
        <strong>各バイトの前に%を追加</strong> - このオプションが選択されると、各2桁の16進数コードの前に%文字が挿入され、URLエンコードしたペイロードを効果的に生成します。
    </li>
</ul>
<h3>総エンコード数</h3>
<p>
    設定値に基づいたエンコードの推定数を表示し、また生成される不正なエンコーディング数の上限も指定できます。大量の冗長エンコーディングや組み合わせの最大化が選択された場合、これらのオプションは膨大な数の不正なエンコーディングを生成する可能性があります。
</p>
<h3>リストアイテムの検索と置換</h3>
<p>
    リストアイテムの文字置換を制御します:
</p>
<ul>
    <li>
        <strong>検索文字</strong> - 各リストアイテムで変更される文字です。リストアイテムで「*」のようなダミー文字を使い、置換が行われる個所を示します。
    </li>
    <li>
        <strong>エンコードして置換する文字</strong> - 不正なエンコーディングを生成する文字で、各リストアイテム内で一致した元の文字を置換します。このオプションはASCII文字自身か、文字の16進数コード2桁(例: 00)を指定します - nullなどの非印刷可能なASCII文字を指定する場合に便利です。
    </li>
</ul>
<p>
    リストアイテムは<a href="#simple-list">シンプルリスト</a>ペイロードタイプと同じ方法で編集できます。
</p>
<h2 id="character-blocks">文字ブロック</h2>
<p>
    指定された文字や文字列のブロックに基づいたペイロードを生成します。ネイティブ(アンマネージド)コンテキストで実行されるソフトウェアの、バッファオーバフローや境界条件の脆弱性を検知する場合に便利です。特定の長さの入力が入力フィルタをバイパスしたり、予期せぬコードパスのきっかけになるなど、ロジックフローの攻撃にも使えます。
</p>
<p>
    次のオプションがあります:
</p>
<ul>
    <li>
        <strong>元文字列</strong> - 文字ブロックを生成する元になる文字列。
    </li>
    <li>
        <strong>最短</strong> - 生成されるブロックサイズの最小値。
    </li>
    <li>
        <strong>最長</strong> - 生成されるブロックサイズの最大値。
    </li>
    <li>
        <strong>増分</strong> - 文字ブロックごとの長さの増分
    </li>
</ul>
<h2 id="numbers">数値</h2>
<p>
    与えられた範囲内で、指定した形式の数値ペイロードを生成します。次のオプションが使用できます。
</p>
<h4>数値範囲</h4>
<p>
    次のオプションを設定できます:
</p>
<ul>
    <li>
        <strong>タイプ</strong> - 定義した順番通りか、またはランダムに生成するか指定します。
    </li>
    <li>
        <strong>From</strong> - 数値を順番に生成する場合、生成される最初の数値です。ランダムの場合、生成されうる最小の数値です。
    </li>
    <li>
        <strong>To</strong> - 数値を順番に生成する場合、生成される最後の数値です(または、増分が指定されている場合はこれを越える直前の値が最後です)。ランダムの場合、生成されうる最大の数値です。
    </li>
    <li>
        <strong>増分</strong> - 数値が順番に生成される場合に有効なオプションで、連続した数値間の増分を指定します。負の値を指定すると、生成される数値は減っていきます。
    </li>
    <li>
        <strong>個数</strong> - 数値をランダムに生成する場合に有効なオプションで、生成されるペイロード数を指定します。重複するペイロードが生成されることに注意してください。
    </li>
</ul>
<div class="highlightedarea">
    <h4>注</h4>
    <p>
        Burpは、数値範囲の設定とペイロードジェネレータ実行時の内部状態に倍精度浮動小数点を使用します。非常に大きな数値、または非常に小さな数値を扱う場合、精度が失われる可能性があります。合計桁数が大きい数値(約12桁以上)で回す場合、攻撃テンプレート内の大きな数値を複数の<a href="../positions.html">ペイロードポジションマーカ</a>に分割して指定し、そこに対してより小さな桁数の数値ペイロードを生成したほうが信頼性が上がります。
    </p>
</div>
<h4>数値フォーマット</h4>
<p>
    次のオプションを設定できます:
</p>
<ul>
    <li>
        <strong>ベース</strong> - 数値を10進数と16進数のどちらの形式で生成するか指定します。
    </li>
    <li>
        <strong>整数部最小桁数</strong> - 各数値の整数部の最小桁数です。小さな数値は左側にゼロで桁をパディングします。
    </li>
    <li>
        <strong>整数部最大桁数</strong> - 各数値の整数部の最大桁数です。より大きな桁数の数値は切り詰められ、最上位の桁から失われます。
    </li>
    <li>
        <strong>小数部最小桁数</strong> - 各数値の小数部(小数点の後ろ) の最小桁数です。小数部の桁数が少ない数値は右側にゼロでパディングします。16進数を生成するとき、このオプションは使用できません。
    </li>
    <li>
        <strong>小数部最大桁数</strong> - 各数値の小数部(小数点の後ろ) の最大桁数です。より多くの小数部がある数値は切り詰められ、最小の桁から失われます。16進数を生成するとき、このオプションは使用できません。
    </li>
</ul>
<p>
    各桁オプションが空白のままの場合、最小または最大桁数は適用されません。現在の数値フォーマット設定で生成される数値の例も表示されます。
</p>
<h2 id="dates">日付</h2>
<p>
    与えられた範囲内で、指定した形式の日付ペイロードを生成します。データマイニング(たとえば日ごとに格納された注文を漁る場合)や、またはブルートフォース(たとえばユーザの機微情報である誕生日を推測する場合)に便利です。
</p>
<p>
    次のオプションがあります:
</p>
<ul>
    <li>
        <strong>From</strong> - 生成する最初の(最も早い)日付です。
    </li>
    <li>
        <strong>To</strong> - 生成する最後の(最も遅い)日付です(または、増分が指定されている場合はこれを越える直前の日付が最後です)。
    </li>
    <li>
        <strong>増分</strong> - 連続する日、週、月または年の増分です。正の値でなければなりません。
    </li>
    <li>
        <strong>形式</strong> - 日付の表示形式です。定義済みの日付形式から選択ができ、またはテキストフィールドに入力してカスタマイズできます。以下は、日付形式をカスタマイズするための構文例です。
    </li>
</ul>
<table class="is-nonresponsive-table">
    <tr>
        <td>
            <code> E </code>
        </td>
        <td>
            <code> Sat </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> EEEE </code>
        </td>
        <td>
            <code> Saturday </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> d </code>
        </td>
        <td>
            <code> 7 </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> dd </code>
        </td>
        <td>
            <code> 07 </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> M </code>
        </td>
        <td>
            <code> 6 </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> MM </code>
        </td>
        <td>
            <code> 06 </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> MMM </code>
        </td>
        <td>
            <code> Jun </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> MMMM </code>
        </td>
        <td>
            <code> June </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> yy </code>
        </td>
        <td>
            <code> 03 </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> yyyy </code>
        </td>
        <td>
            <code> 2003 </code>
        </td>
    </tr>
    <tr>
        <td>
            <code> / . : など </code>
        </td>
        <td>
            <code> / . : </code>
        </td>
    </tr>
</table>
<h2 id="brute-forcer">ブルートフォース</h2>
<p>
    指定した長さ、文字セットから、すべての組み合わせのペイロードを生成します。
</p>
<p>
    次のオプションがあります:
</p>
<ul>
    <li>
        <strong>文字セット</strong> - ペイロードで使用される文字のセット。このセットのサイズによって、生成されるペイロードの合計数が指数関数的に増加する点に注意してください。
    </li>
    <li>
        <strong>最短</strong> - 最低ペイロード長。
    </li>
    <li>
        <strong>最長</strong> - 最高ペイロード長。
    </li>
</ul>
<h2 id="null-payloads">ペイロードなし</h2>
<p>
    ペイロード値が空の文字列を生成します。
</p>
<p>
    同じリクエストに対して、元のベーステンプレートに変更を加えることなく、繰り返し攻撃が必要な場合に便利です。これはさまざまな攻撃に使え、たとえばシーケンス分析のためのcookie収集、サーバ上で高負荷なタスクを繰り返しリクエストするアプリケーション層へのサービス妨害攻撃、他の断続的なテストで使用されているセッショントークンを維持する、などです。
</p>
<p>
    このペイロードタイプでは、リクエストテンプレートで<a href="../positions.html">ペイロードポジションマーカ</a>を使う必要はありません。
</p>
<p>
    ペイロードを生成する数を指定するか、無限に継続するか設定できます。
</p>
<h2 id="character-frobber">文字フロバー</h2>
<p>
    このペイロードタイプは入力文字列に対して、各位置の文字を順番に変更していきます。これはペイロードポジションで指定された既存の文字列をベースにもできますし、指定した文字列でも可能です。1回あたり、ベース文字列中の1文字についてASCIIコードを1つ増やした文字に変える操作を、文字数分行います。
</p>
<p>
    このペイロードタイプは、どのパラメータ値、また値のどの部分が、アプリケーションの応答に影響があるのかをテストする場合に有効です。特に、複雑なセッショントークンのどの部分が、実際にセッション状態を追跡するために使われているかテストする場合に便利です。もしセッショントークン内の一部の文字を変更してもまだセッションが維持されているようであれば、その文字はセッションで使用されていない可能性があります。
</p>
<h2 id="bit-flipper">ビットフリッパー</h2>
<p>
    このペイロードタイプは入力値に対して、各ビット位置の値を順番に変更していきます。これはペイロードポジションで指定された既存の文字列をベースにもできますし、指定した文字列でも可能です。1回あたり、ベース文字列の1文字を対象として、各(指定された)ビットを順番に反転します。
</p>
<p>
    次のオプションがあります:
</p>
<ul>
    <li>
        <strong>処理対象</strong> - 元値に、ペイロードポジションの値か、あるいは他の文字列を使用するか指定します。
    </li>
    <li>
        <strong>元値のフォーマット</strong> - 元データを、リテラル値として扱うか、ASCII16進数として扱う(後述)か指定します。
    </li>
    <li>
        <strong>反転するビットを選択</strong> - 最下位ビット(つまり0000000X)から最上位ビット(つまりX0000000)まで、各バイトのどのビットを反転するか指定します。
    </li>
</ul>
<p>
    元の値をリテラル値として扱うか、ASCII16進数として扱うか設定できます。たとえば、元の値が"ab"の場合、リテラル文字列として動作してすべてのビットを反転すると次のペイロードになります:
</p>
<code> `b<br>cb<br>eb<br>ib<br>qb<br>Ab<br>!b<br>áb<br>ac<br>a`<br>af<br>aj<br>ar<br>aB<br>a"<br>aâ<br>
</code><p>
    一方、ASCII16進数文字列として"ab"を扱い、すべてのビットを反転すると次のペイロードになります:
</p>
<code> aa<br>a9<br>af<br>a3<br>bb<br>8b<br>eb<br>2b<br>
</code><p>
    このペイロードタイプは、<a href="#character-frobber">文字フロバー</a>をさらにきめ細かく制御する必要がある状況で役立ちます。たとえば、CBCモードのブロック暗号で意味にあるデータが暗号化されてセッショントークンや他のパラメータ値に含まれる場合、暗号ブロック内の直前のビットを変更すると、復元されるデータの一部を体系的に変更できる可能性があります。このような状況で、ビットフリッパーのペイロードタイプを使用すると、暗号化されたデータ内の個々のビット変更による効果を判断し、アプリケーションが脆弱かどうか理解できます。
</p>
<h2 id="username-generator">ユーザ名ジェネレータ</h2>
<p>
    名前や電子メールアドレスの一覧を設定し、そこから一般的な生成規則を使用してさまざまな潜在的なユーザ名を生成します。
</p>
<p>
    たとえば、"peter weiner"という名前を指定すると、次のような115通り以上の結果になります:
</p>
<code class="code-scrollable">peterweiner peter.weiner weinerpeter weiner.peter peter weiner peterw peter.w wpeter w.peter pweiner p.weiner weinerp weiner.p etc...</code><p>
    特定の個人ユーザを狙っていて、しかしアプリケーション内で使用されているユーザ名やメールアドレスの生成規則がわからない場合には、このペイロードタイプが便利です。
</p>
<p>
    リストアイテムは<a href="#simple-list">シンプルリスト</a>ペイロードタイプと同じ方法で編集できます。リストの1アイテムごとに生成するペイロードの最大数も設定できます。
</p>
<h2 id="ecb-block-shuffler">ECBブロックシャッフル</h2>
<p>
    このペイロードは、ECBで暗号化されたデータの暗号文ブロックを並び替えます。その結果、復号した際に意味のある平文になり、アプリケーションロジックが不安定になる可能性があります。
</p>
<p>
    ECB暗号は、他のブロックとは関係なく平文のブロックを暗号化するため、(同じ鍵を使っていれば)同じ平文が暗号化されると同じ暗号文になり、またその逆も起こります。したがって、暗号文の大部分のブロックを並べ替えると、復号された平文のブロックも並び替えられる可能性があります。一部のデータ(ユーザ名、ユーザID、ロール、タイムスタンプのフィールドを持つ構造化されたセッショントークンなど)では、解読された際に意味のあるデータ内容になるよう変更し、アプリケーション処理を不安定にしたり、許可されていない処理を実行できる可能性があります。
</p>
<p>
    次のオプションがあります:
</p>
<ul>
    <li>
        <strong>シャッフルする暗号データ</strong> - ペイロードポジションの値か、あるいはその他の文字列をベースに動作するか指定します。
    </li>
    <li>
        <strong>元値のフォーマット</strong> - 元データを、リテラル値として扱うか、ASCII16進数として扱うか指定します。(詳細は<a href="#bit-flipper">ビットフリッパー</a>ペイロードタイプを参照してください)。
    </li>
    <li>
        <strong>ブロックサイズ</strong> - 暗号化されたブロックのバイト単位のサイズです。ほとんどのケースでブロックサイズは、8 または 16 バイトです。確証がない場合は、使用される可能性があるブロックサイズをそれぞれ使用して、複数回攻撃を実行してみてください。
    </li>
    <li>
        <strong>追加暗号文字列</strong> - 必要に応じて、同じ暗号と鍵が使われている暗号文字列のリストを設定し、暗号化データの並べ替えに使用する追加ブロックを指定できます。このタイプの攻撃を成功させるには、構造上適切なポイントに当てはまる平文のブロックを探し出す必要なため、かなりの幸運が必要です。同じアプリケーションが暗号化した文字列を、大量に収集すると成功確率が上がります。たとえば、このペイロードタイプを使用してセッショントークンを攻撃する場合は、アプリケーションから他のセッショントークンを大量に収集し、暗号文の追加ブロックに指定すると有効でしょう。<strong>重複排除</strong>オプションは、リストから重複するエントリを削除します。これにより、送信されるリクエストの数が減り、攻撃の効率が向上します。
    </li>
</ul>
<h2 id="extension-generated">拡張による生成</h2>
<p>
    ペイロードを生成する<a href="../../../extensions/index.html">Burp拡張</a>を呼び出します。Intruderのペイロードジェネレータとして、その拡張が登録されている必要があります。現在読み込まれている拡張によって登録されている、使用可能なジェネレータの一覧から、必要なジェネレータを選択できます。
</p>
<h2 id="copy-other-payload">他ペイロードコピー</h2>
<p>
    このペイロードタイプは、別ペイロードの値を、現在のペイロード値にコピーします。複数のペイロードセットを持つ<a href="../attack-types.html">攻撃タイプ</a>(<a href="../attack-types.html#cluster-bomb">クラスター爆弾</a>と<a href="../attack-types.html#battering-ram">破城槌</a>)で使用できます。<a href="processing.html">ペイロード処理ルール</a>も定義できるので、別のペイロードポジションのリテラル値をコピーするだけではなく、その値から現在のペイロードを体系的に派生できます。
</p>
<p>
    このペイロード タイプは、さまざまな状況で便利です、例:
</p>
<ul>
    <li>
        対象の処理に適合するには、2つの異なるパラメータで同じ値を使わなければならない場合(たとえば、新しいパスワードとその確認)で、他のパラメータの操作にクラスター爆弾攻撃を使いたい場合。
    </li>
    <li>
        リクエスト内のあるパラメータが他のパラメータ値のチェックサムを持っていて、ユーザの入力に基づいてクライアント側のスクリプトが計算している場合。
    </li>
</ul>
</body>
</html>