<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../../../assets/ps/styles/psselfservice.css">
<cms page-layout="FREESTYLE"></cms>
</head>
<body class="section theme-white wrapper-themed">
<section class="container ps-breadcrumbs">
    <ol class="breadcrumb-list">
        <li>
            <a href="https://portswigger.net/support">サポートセンタ</a>
        </li>
        <li>
            <a href="../../index.html">ドキュメント</a>
        </li>
        <li>
            <a href="../index.html">デスクトップ版</a>
        </li>
        <li>
            <a href="index.html">Webサイトのスキャン</a>
        </li>
        <li>
            <a href="audit-options.html">診断オプション</a>
        </li>
    </ol>
</section>
<section class="container labels-editions-wrapper">
    <label class="label-edition is-professional">Professional</label>
</section>
<h1>診断オプション</h1>
<p>
    診断スキャン中のBurp Scannerの挙動を設定する多数のオプションがあります。これらは<a href="../scanning/scan-launcher.html">スキャン開始時</a>にその場で設定でき、またBurpの<a href="../configurations.html#configuration-library">設定ライブラリ</a>でも管理できます。
</p>
<div class="highlightedarea">
    <h4>注</h4>
    <p>
        Burp Suiteの設定ライブラリには<a href="built-in-configurations.html">組み込み設定</a>が用意されているので、これらのオプションを素早く設定できます。
    </p>
</div>
<h2 id="audit-optimization">診断の最適化</h2>
<p>
    診断の目的や対象アプリケーションの性質に応じて、診断ロジックの挙動を調整できます。
</p>
<p>
    次のオプションがあります:
</p>
<ul>
    <li>
        <strong>診断スピード</strong> - 脆弱性をチェックする際に、診断チェックをどの程度徹底的に行うかを設定します。<strong>高速</strong>設定は、リクエストが少なくなり、一部の脆弱性でチェックパターンが少なくなります。<strong>徹底的</strong>設定は、より多くのリクエストを発行し、脆弱性のより多くのパターンをチェックします。<strong>標準</strong>設定は2つの中間で、多くのアプリケーションにとって適切な、速度と網羅性のバランスになります。
    </li>
    <li>
        <strong>診断精度</strong> - 特定タイプの脆弱性を報告する場合にScannerが必要とする、証跡の量を設定します。一部の問題は"ブラインド"手法でのみ検出でき、時間遅延やレスポンス差分のような、観測された挙動を元に脆弱性が存在するか推測します。対象の脆弱性が存在しない場合でも、このような挙動はいつでも発生し観測される可能性があるため、エラーメッセージの観測などのような他の手法に比べて、この手法は本質的に過剰検知する傾向にあります。Burpは過剰検知を減らすために、問題を推定したときに何度かテストを繰り返し、送信した入力値と観測した挙動の間に信頼できる相関があるか確認しようとします。精度設定は、Burpがこれらのテストを何回再試行するか制御します。<strong>検知漏れを最小化</strong>設定は、再試行回数が少なくなり、過剰検知が報告される可能性が高くなりますが、アプリケーションの挙動が安定しない場合でも、存在する脆弱性の見逃しが減ります。<strong>過剰検知を最小化</strong>設定は、再試行回数が多くなり、問題の過剰検知が報告される可能性が低くなりますが、一部のテストリクエストに結果が返ってこないことがあると、存在する問題を誤って見逃す可能性があります。<strong>標準</strong>設定は2つの中間で、多くのアプリケーションにとって適切な、過剰検知と検知漏れのバランスになります。
    </li>
    <li>
        <strong>影響がなさそうな挿入ポイントの元値のチェックをスキップする</strong> - 各挿入ポイントのパラメータの元値を考慮し、無関係と思われるチェックを省略して、スキャンの効率を向上させます。たとえば、通常はファイル名に使われない文字がパラメータ値に含まれている場合、このパラメータのファイルパストラバーサルチェックを省略します。このオプションを使用すると、本当は存在する脆弱性を見逃すリスクを比較的低く抑えながら、スキャンの速度を上げられます。
    </li>
    <li>
        <strong>頻繁に発生するパッシブ問題を統合する</strong> - <a href="../../scanner/auditing.html#consolidation-of-frequently-occurring-passive-issues">頻繁に発生するパッシブ問題を統合する</a>かどうかコントロールします。このオプションを使用すると、同じ問題(クリックジャッキングなど)が多くの箇所やアプリケーション全体に表示されるノイズを大幅に軽減します。
    </li>
    <li>
        <strong>自動的にセッションを維持する</strong> - スキャンの診断フェーズ中に<a href="../../scanner/auditing.html#automatic-session-handling">自動的にセッションを維持する</a>かどうか制御します。クロールフェーズで発見されたナビゲーション経路を使用して診断フェーズでセッションを維持できる、クロール駆動の診断にのみ適用できます。最近のアプリケーションでは通常、網羅的に診断を行うにはセッションの維持が不可欠です。ただし、セッションの維持に多くのリクエストが必要で負荷があり、必要でないことがわかっている場合には、このオプションを無効にできます。
    </li>
    <li>
        <strong>必要な箇所でリダイレクトをたどる</strong> -&nbsp; 一部の脆弱性(たとえば、リダイレクトをたどった後に返されるエラーメッセージ内のクロスサイトスクリプティング)は、リダイレクトをたどった場合のみ検出できます。一部のアプリケーションは、送信したパラメータをURLに含む外部のURLへのリダイレクトを発行する場合がありますが、外部アプリケーションへの攻撃を防ぐため、Burpは受信したリダイレクトをすべてたどるわけではありません。スキャンされているリクエストが定義済みの<a href="../tools/target/scope.html">ターゲットスコープ</a>内の場合(つまり、スキャンされる対象を制御するためターゲットスコープを使用している場合)、同じスコープ内の場合にのみリダイレクトをたどります。スキャンされているリクエストがスコープ外の場合(つまり、スコープ外リクエストのスキャンを手動で開始した場合)は、(a)スキャンしているリクエストと同じホスト/ポートである場合; かつ(b)全体のスコープ除外ルール(たとえば"logout.aspx")で明示的に指定されていない場合にのみ、Burpはリダイレクトをたどります。
    </li>
</ul>
<h2 id="issues-reported">報告される問題</h2>
<p>
    Burpがチェックする<a href="https://portswigger.net/kb/issues">項目</a>を制御します。
</p>
<p>
    個別、または検出したアイテムに関連する<a href="../../scanner/auditing.html#issue-types">診断アクティビティ</a>の性質に従って、問題タイプを選択できます。個々の項目を選択する場合、使用する検出方法も一部の項目では選択できます。関連する項目のコンテキストメニューから、<strong>検出手法を編集</strong>を選択してください。
</p>
<p>
    各チェックを実行すると、生成されるリクエストが増え、各診断に時間がかかります。アプリケーションの技術に関する知見を元に、個々の項目のオン/オフを切り替えられます。たとえば、アプリケーションがLDAPを使用していないと分かっている場合、LDAPインジェクションをオフにできます。または、アプリケーションが使用しているバックエンドデータベースが分かっている場合、他のデータベースタイプに固有のSQLインジェクション検出手法をオフにできます。
</p>
<div class="highlightedarea">
    <h4>注</h4>
    <p>
        <strong>アクティブ</strong>にラベルされた項目が有効な場合、これらの問題を発見するよう設計されたリクエストをアプリケーションに送信します。選択された項目によっては、これらのリクエストは悪意のあるものと見なされたり、アプリケーションやそのデータに損害を与える可能性があります。
    </p>
</div>
<h2 id="handling-application-errors-during-audit">診断中のアプリケーションエラーの処理</h2>
<p>
    スキャンの診断フェーズで発生する<a href="../../scanner/auditing.html#handling-application-errors">アプリケーションエラー</a>(接続エラーや送信タイムアウトなど)の処理方法を制御します。
</p>
<p>
    次のオプションを設定できます:
</p>
<ul>
    <li>
        その挿入ポイントの残りのチェックをスキップするまでの、連続して診断チェックが失敗した回数。
    </li>
    <li>
        残りの挿入ポイントをスキップし、診断アイテムを失敗としてフラグを立てるまでの、失敗した挿入ポイントの数。
    </li>
    <li>
        タスクを停止するまでの、連続して失敗した診断項目数、または失敗した診断項目全体の割合。
    </li>
    <li>
        失敗した操作を再試行するために、各診断フェーズの終了時に追加確認する回数。
    </li>
</ul>
<p>
    空白のままにしておくと、無効にできます。
</p>
<h2 id="insertion-point-types">挿入ポイントタイプ</h2>
<p>
    診断する各HTTPリクエストのどこに、Scannerが<a href="../../scanner/auditing.html#insertion-points">挿入ポイント</a>を配置するかを制御します。
</p>
<p>
    挿入ポイントの配置位置はきめ細かく設定でき、注意深く設定すれば対象のアプリケーションの性質に合わせた診断を調整できます。挿入ポイントの設定は、スキャンの速度と網羅性のトレードオフになります。
</p>
<p>
    次のカテゴリーの挿入ポイントを選択できます:
</p>
<ul>
    <li>
        <strong>URLパラメータ値</strong> - URLクエリーストリング内の標準的なパラメータ値
    </li>
    <li>
        <strong>ボディのパラメータ値</strong> - メッセージボディのパラメータ値。標準的なフォーム送信パラメータ、アップロードするファイル名などマルチパートエンコードされたパラメータの属性、XMLパラメータ値と属性、JSONの値があります。
    </li>
    <li>
        <strong>cookieの値</strong> - HTTP cookieの値
    </li>
    <li>
        <strong>パラメータ名</strong> - 任意の追加パラメータ名。URLパラメータは常に追加され、POSTリクエストではボディパラメータも追加されます。パラメータ値のみテストしている場合に見逃されているバグを、パラメータ名のテストでよく見つけられます。
    </li>
    <li>
        <strong>HTTPヘッダ</strong> - RefererとUser-Agentヘッダの値。これらの挿入ポイントのテストによって、ログ機能のSQLインジェクションや永続的なXSSの問題をよく見つけられます。
    </li>
    <li>
        <strong>ボディ全体</strong> - リクエストボディ全体。リクエストボディがXMLまたはJSONのリクエストに適用されます。
    </li>
    <li>
        <strong>URLパスのファイル名</strong> - URLパスのファイル名の部分(最後のフォルダパスの後ろでクエリーストリングの前)
    </li>
    <li>
        <strong>URLパスのフォルダ</strong> - URLパスのすべてのフォルダトークンの値(ファイル名部分の前)。
    </li>
</ul>
<div class="highlightedarea">
    <h4>注</h4>
    <p>
        Burpに自動的に挿入ポイントを割り当てさせるだけではなく、すべてカスタマイズが可能で、リクエスト内の任意の位置を攻撃対象として指定できます。この機能を使うには、リクエストをIntruderに送信し、<a href="../tools/intruder/positions.html">ペイロードポジション</a>タブで通常の方法で挿入ポイントを定義し、Intruderメニューオプションから<strong>定義した挿入ポイントを診断</strong>を選択します。または<a href="../tools/extender/index.html">Burp Extender</a>を使って、プログラムでカスタムの挿入ポイントも指定できます。
    </p>
</div>
<h2 id="modifying-parameter-locations-options">パラメータ位置の操作オプション</h2>
<p>
    これらの設定は、パラメータの元の位置でのテストに加え、リクエスト内の別の場所に<a href="../../scanner/auditing.html#modifying-parameter-locations">パラメータを移動</a>する設定です。たとえば、各URLパラメータをメッセージボディに移動し再テストできます。または、各ボディパラメータをcookieに移動し、再テストできます。
</p>
<p>
    この方法でパラメータを移動すると、防御フィルターをバイパスできることがよくあります。多くのアプリケーションやアプリケーションファイアウォールは、パラメータがリクエスト内の期待している場所にあると仮定してパラメータごとに入力検証をします。パラメータを別の場所に移動すると、この検証が回避できます。アプリケーションがその後、メインロジックの実装でそのパラメータを取得する場合、パラメータの場所に依存しないAPIを使用している可能性があります。よって、通常は処理される前にフィルターされてしまう入力を、脆弱なコードパスに到達させるのにパラメータの移動は有効です。
</p>
<p>
    パラメータ位置の変更は、次のオプションがあります:
</p>
<ul>
    <li>
        URLからボディ
    </li>
    <li>
        URLからcookie
    </li>
    <li>
        ボディからURL
    </li>
    <li>
        ボディからcookie
    </li>
    <li>
        cookieからURL
    </li>
    <li>
        cookieからボディ
    </li>
</ul>
<p>
    パラメータ位置を変更すると、各リクエストパラメータが複数回スキャンされることになるため、スキャンリクストがより多くなります。
</p>
<h2 id="ignored-insertion-points">挿入ポイントの無視</h2>
<p>
    Burpが特定の診断を省略するリクエストパラメータを指定します。サーバ側インジェクションチェック(SQLインジェクションなど)をスキップするか、すべてのチェックをスキップする設定が別にあります。
</p>
<p>
    サーバ側インジェクションチェックは、さまざまなサーバ上の脆弱性を手探りで調べるために複数のリクエストを送信するので、比較的時間がかかります。リクエスト内の特定のパラメータに脆弱性がないと考える場合(たとえば、プラットフォームやWebサーバのみが使用する組み込みパラメータなど)、Burpにこれらのテストをしないよう指示できます。(クロスサイトスクリプティングのようなクライアント側のバグのテストは、パラメータが脆弱ではない場合にスキャン中の負荷が最小限になるよう抑えられています。)
</p>
<p>
    テストしたくないアプリケーションコンポーネントに処理されるパラメータや、変更するとアプリケーションが不安定になると分かっている場合は、すべてのチェックの省略が便利です。
</p>
<p>
    各一覧のアイテムでは、パラメータタイプ、マッチさせるアイテム(名前または値)、マッチの種類(リテラル文字列または正規表現)、マッチさせる文字列を指定します。
</p>
<p>
    URLパス内の(スラッシュで区切られた)それぞれのURLパスフォルダがパラメータになっている場合があります。これを行うには、検索アイテムのドロップダウンから<strong>URLパスのフォルダ</strong>を、名前または値のドロップダウンで"名前"を選択し、テストから除外したいURLパスのインデックス番号(1オリジン)を指定します。URLパスのフォルダパラメータは、値でも指定できます。
</p>
<h2 id="frequently-occurring-insertion-points">頻繁に発生する挿入ポイント</h2>
<p>
    <a href="../../scanner/auditing.html#handling-of-frequently-occurring-insertion-points">頻繁に発生する挿入ポイント</a>でBurp Scannerに重複を避けさせるかどうかを設定できます。設定された場合、Burpは意味がなさそうな(頻繁に発生するが問題が見つかっていない)ことが判明している挿入ポイントを特定し、それらの挿入ポイントにより軽量な診断をするようになります。
</p>
<p>
    この最適化が適用される挿入ポイントのタイプを選択できます。
</p>
<h2 id="misc-insertion-point-options">その他の挿入ポイントオプション</h2>
<p>
    <a href="../../scanner/auditing.html#nested-insertion-points">ネストした挿入ポイント</a>を使用するかどうか選択できます。挿入ポイントの元の値が認識可能な形式のデータを含む場合に、ネストした挿入ポイントが使われます。たとえば、URLパラメータにBase64エンコードされたデータがあり、デコードした値にJSONやXMLデータが含まれているなどです。ネストした挿入ポイントのオプションを使うと、ネストした各レベルごとの入力アイテムをそれぞれ挿入ポイントとして作成します。このオプションを使うと、従来通りのリクエストパラメータのみが含まれるリクエストではオーバーヘッドにはならず、異なる形式でデータがカプセル化された複雑なアプリケーションでより多くの攻撃経路にたどりつけます。
</p>
<p>
    膨大な数のパラメータを含むリクエストがあった場合にスキャンが停止するのを防ぐために、ベースリクエストごとに生成される挿入ポイント数の制限を設定できます。この設定により挿入ポイント数が削減されている場合、<a href="audit-items.html">診断アイテムビュー</a>のアイテムのエントリには、省略された挿入ポイントの数が表示されるため、手動でベースリクエストをレビューし、可能なすべての挿入ポイントをフルスキャンする価値があるかどうか判断できます。
</p>
<h2 id="javascript-analysis-options">JavaScript分析オプション</h2>
<p>
    これらの設定は、Burp ScannerがDOMベースの脆弱性をJavaScriptから検出する方法を制御します。次のオプションがあります:
</p>
<ul>
    <li>
        <strong>不足しているサイトリソースをリクエストする</strong> - Burp ScannerがJavaScriptファイルなど欠損している依存関係に対してHTTPリクエストを行うかどうかを制御します。
    </li>
    <li>
        <strong>以前に検出されなかったリソースをスコープ外のホストからロードする</strong> - ページで参照されているが、クロール中にBurp Scannerによって検出されてい<strong>ない</strong>リソースを、スキャン範囲外の場所から読み込むかどうかを制御します。次のようなものに対して診断のみのスキャンを実行すると、このシナリオが発生する可能性があります: <ul>
            <li>
                手動でサイトを探索しているときに発見したアイテム
            </li>
            <li>
                以前のスキャンでサイトマップに追加されたが、実際のWebサイトで変更されたアイテム
            </li>
        </ul>
        このオプションを無効にすると、診断中にこれらのリソースを読み込まず、結果として脆弱性を見逃す可能性があります。たとえば、ページは最初は安全であったが、実行時に外部JavaScriptファイルを読み込んだ際に動的に脆弱性が引き起こされるかもしれません。
    </li>
    <li>
        <strong>静的/動的分析手法を使用する</strong> - Burp Scannerが全体のJavaScript分析で、<a href="../../scanner/auditing.html#javascript-analysis">静的あるいは動的な手法</a>、またはその両方を使用するかどうかを制御します。DOMベースの問題について<a href="#issues-reported">検出手法</a>の有効化を編集すると、個別の問題タイプごとに静的または動的手法を使用するかどうかも設定できます。
    </li>
    <li>
        <strong>アイテムごとの最大静的/動的分析時間</strong> - スキャンされる個々のアイテムごとに静的または動的分析に費やす最大時間を設定できます。非常に大きく複雑なスクリプトを含むアイテムに遭遇した場合、静的分析エンジンが過剰なシステムリソースを消費する可能性があるため、この設定が有用です。最大時間に達したため分析を中断した場合、その影響を受けたアイテムが特定できる警告を表示します。ゼロまたは空白値を指定すると、無制限が適用されます。
    </li>
</ul>
<div class="highlightedarea">
    <h4>注</h4>
    <p>
        JavaScript分析は大量のメモリと計算能力を消費する可能性があるため、重要で主要な対象のみに制限した方が望ましい場合があります。さらに、JavaScript分析を実行する場合は、より多くのメモリを割り当ててBurpを起動する必要があります。そのためには、<a href="../getting-started/launch-from-command-line.html">Burpをコマンドラインから起動</a>する必要があります。
    </p>
</div>
</body>
</html>