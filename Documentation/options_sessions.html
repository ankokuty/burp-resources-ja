<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="css/ps.css">
</head>
<body>
<section class="container ps-breadcrumbs">
    <ol itemscope itemtype="http://schema.org/BreadcrumbList">
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="https://support.portswigger.net/">
            <span itemprop="name">サポートセンター</span>
            <meta itemprop="position" content="1"/>
            </a>
        </li>
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="index.html">
            <span itemprop="name">ドキュメント</span>
            <meta itemprop="position" content="2"/>
            </a>
        </li>
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="options.html">
            <span itemprop="name">オプション</span>
            <meta itemprop="position" content="3"/>
            </a>
        </li>
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="options_sessions.html">
            <span itemprop="name">セッション</span>
            <meta itemprop="position" content="4"/>
            </a>
        </li>
    </ol>
</section>
<section class="maincontainer">
    <div class="container main">
        <h1>オプション: セッション</h1>
        <p>
            このタブには、<a href="#sessionrules">セッションハンドリングルール</a>、<a href="#cookiejar">cookie jar</a>、<a href="#macros">マクロ</a>の設定があります。
        </p>
        <a name="challenges"></a>
        <h2>セッションハンドリングの課題</h2>
        <p>
            あるタイプのWebアプリケーションのテストを実行すると、、セッション処理や状態に関する問題が発生するかもしれません。例:
        </p>
        <ul>
            <li>
                防御またはその他の理由で、テストで使用していたセッションを破棄する可能性があり、セッションが復元されるまで後続のテストは効果的ではありません。
            </li>
            <li>
                一部の機能は、(例えばリクエストフォージェリ攻撃を防ぐため)に各リクエストごとに変化するトークンを使用するかもしれません。
            </li>
            <li>
                一部の機能は、テスト中のリクエストを許可するために適した状態を得るために、テスト中のリクエストの前に一連のリクエストを発行する必要があります。
            </li>
        </ul>
        <p>
            これらの問題は、ファジングやスキャンなどの自動化されたテストタスクを実行するときや、手動でテストしている場合にも発生する可能性があります。
        </p>
        <p>
            Burpのセッションハンドリング機能には、これらの状況を補助する幅広い機能があり、Burpがこれらの問題を裏で処理している間に、手動または自動のテストを継続できます。
        </p>
        <a name="sessionrules"></a>
        <h2>セッションハンドリングルール</h2>
        <p>
            Burpはセッションハンドリングルールのリストを定義でき、アプリケーションのセッションハンドリング機構や関連する機能をBurpがどう扱うか、非常にきめ細かく制御できます。
        </p>
        <p>
            各ルールにはスコープ(ルールを適用する対象)とアクション(ルールの動作)があります。Burpが作成した外向きのリクエストごとに、そのリクエストが定義したスコープ内か判断し、全てのルールのアクションを順番に実行します(状態チェックアクションがさらなるアクションを適用すべきではないと判断した場合を除く)。
        </p>
        <p>
            各ルールのスコープは、リクエストを処理する次の機能の、任意または全てに基づいて定義できます:
        </p>
        <ul>
            <li>
                リクエストを生成するBurp<a href="options_sessions_ruleeditor.html#toolsscope">ツール</a>
            </li>
            <li>
                リクエストの<a href="options_sessions_ruleeditor.html#urlscope">URL</a>
            </li>
            <li>
                リクエスト内の<a href="options_sessions_ruleeditor.html#paramscope">パラメーター</a>の名前
            </li>
        </ul>
        <p>
            各ルールは、１つまたは複数の<a href="options_sessions_ruleeditor.html#actions">アクション</a>を実行できます。例:
        </p>
        <ul>
            <li>
                Burpのcookie jarからcookieを更新する
            </li>
            <li>
                現在のセッションを検証する
            </li>
            <li>
                マクロ(定義済みの一連のリクエスト)を実行する
            </li>
        </ul>
        <p>
            異なるスコープとアクションの複数のルールを作ると、異なるアプリケーションや機能に適用する動作の階層を定義できます。例えば、特定のテストで次のルールを定義します
        </p>
        <ul>
            <li>
                全てのリクエストに対して、Burpの cookie jarからcookieを追加する。
            </li>
            <li>
                特定のドメインに対して、アプリケーションがまだアクティブなままか検証し、もし違う場合は、アプリケーションにログインし直すマクロを実行し、結果のセッショントークンでcookie jarを更新する。
            </li>
            <li>
                <span class="InlineCode">__csrftoken</span>パラメーターを含む特定のURLに対して、有効な<span class="InlineCode">__csrftoken</span>値を取得するマクロをまず実行し、リクエスト生成時にそれを使用する。
            </li>
        </ul>
        <p>
            セッションハンドリングルールの設定詳細については、<a href="options_sessions_ruleeditor.html">セッションハンドリングルールエディター</a>のヘルプを参照してください。
        </p>
        <a name="sessionrules_tracer"></a>
        <h3>セッションハンドリングトレーサー</h3>
        <p>
            Burpのセッションハンドリング機能を現実のアプリケーションに適用するために必要な設定は、多くの場合複雑でミスが起こりやすいです。セッションハンドリングトレーサーを使用して、セッションハンドリングルールのトラブルシューティングを支援できます。
        </p>
        <p>
            トレーサーは、セッションハンドリング機能が処理したリクエスト(つまり、最後のセッションルールが適用された箇所)のリストを表示します。処理された各リクエストごとに、実行されたルールの配列とアクションを表示し、配列のステップごとに現在のリクエストに起こった変更を表示します。&nbsp;
        </p>
        <p>
            セッションハンドリングトレーサーは、影響を受ける全てのHTTPリクエストで処理され、ストレージに負荷がかかることに注意してください。セッションハンドリングルールのトラブルシューティングするときだけトレーサーを使用するべきで、通常は実行し続けないようにしてください。
        </p>
        <a name="cookiejar"></a>
        <h2>Cookie Jar</h2>
        <p>
            Burpは、アクセスしたWebサイトが発行した全てのcookieを格納するcookie jarを保持します。cookie jarは、全てのBurpツールで共有されます。
        </p>
        <p>
            cookieを更新するために、cookie jarがモニタリングするツールを設定できます。デフォルトでcookie jarは、ProxyとSpiderツールのトラフィックに基づいて更新されます。設定されたツールが受信したレスポンスをBurpが監視し、新たなcookieがセットされたらcookie jarを更新します。Proxyの場合、ブラウザから受信したリクエストも検査します。以前アプリケーションがブラウザに永続的なcookieをセットしていて、それがセッションの適切な取り扱いに必要とされる場合に、この機能が便利です。Proxyを経由するリクエストを元にcookie jarを更新するということは、現在のアクセスでアプリケーションがcookieの値を更新しない場合でも、全ての必要なcookieがcookie jarに追加されます。
        </p>
        <p>
            "cookie jarを開く"ボタンを使用して、cookie jarの内容の表示や、cookieを手動で編集ができます。
        </p>
        <p>
            送信するリクエストのcookieを自動で更新するために、cookie jarは<a href="#sessionrules">セッションハンドリングルール</a>や<a href="#macros">マクロ</a>でも使用されます。
        </p>
        <p>
            Internet Explorererのcookie解釈の仕様をまねて、cookie jarは、cookieのドメインやパススコープに従います。
        </p>
        <a name="macros"></a>
        <h2>マクロ</h2>
        <p>
            マクロは、１つ以上の一連のリクエストの定義です。<a href="#sessionrules">セッションハンドリングルール</a>内でマクロが使用でき、様々なタスクを実行できます。マクロの典型的な使用例は次の通りです:
        </p>
        <ul>
            <li>
                (ユーザーのホームページなど)アプリケーションのページを取得して、現在のセッションがまだ有効か確認する
            </li>
            <li>
                新しい有効なセッションを取得するためのログインを実行する
            </li>
            <li>
                別のリクエストのパラメーターとして使用するトークンまたはnonceを取得する
            </li>
            <li>
                多段階処理のリクエストをスキャンまたはファジングする際、必要な前処理リクエストを実行し、アプリケーションが対象のリクエストを受け入れられる状態にする
            </li>
            <li>
                多段階処理で、"攻撃"リクエストの後、処理の残りの手順を完了し実行されたアクションを確認する、またはその処理の結果やエラーメッセージを取得する
            </li>
        </ul>
        <p>
            基本的なリクエストの順序と同様に、cookieやパラメーターの処理方法やアイテム間の依存関係など、各マクロにはいくつかの重要な設定があります。
        </p>
        <p>
            マクロの設定の詳細は、<a href="options_sessions_macroeditor.html">マクロエディター</a>のヘルプを参照してください。
        </p>
        <a name="toolsintegration"></a>
        <h2>Burpツールとの統合</h2>
        <p>
            Burpのセッションハンドリング機能は、Burpのその他の機能と重要な連携をします:
        </p>
        <ul>
            <li>
                ScannerやSpiderが生成するcookie付きのリクエストをcookie jarで更新する、デフォルトのセッションハンドリングルールがあります。これで全ての自動巡回とスキャンのリクエストがセッション内で生成され、ブラウザの有効なセッションを維持します。また、以前のステートファイルから読み込まれたアクティブスキャンキュー内のアイテムは、ステートファイルが保存されたときにアクティブだったセッションではなく、現在のセッション内でスキャンされることを意味します。これが必要な動作でない場合は、スキャンを実行する前にデフォルトのセッションハンドリングルールを無効にする必要があります。
            </li>
            <li>
                セッションハンドリングルールがリクエストを発行する前に変更する場合(たとえば、cookieやその他のパラメーターを更新するなど)、分かりやすくするために、更新された最終リクエストがBurpのツール中に表示されます。これは、Intruder、Repeater、Spiderの各ツールに適用されます。レポートされたスキャナーの問題内に表示されるリクエストは、必要に応じて、元のリクエストを表示させ続け、ベースのリクエストとの明確な比較を容易にします。セッションハンドラに変更されたスキャン項目の最終的なリクエストを観察するには、Burp Repeaterにリクエストを送信し発行してください(スキャナーと同じセッションハンドリングルールが有効な場合)。
            </li>
            <li>
                ScannerまたはIntruderが、セッションハンドリングアクションの影響を受けるcookieやパラメーターを操作するリクエストを行う場合、実行中のテストの妨げにならないようそのリクエストに対してアクションは適用されません。例えば、Intruderを使用してリクエストの全てのパラメーターにファジングをする場合、リクエストの"sessid"cookieを更新するセッションハンドリングルールを設定していると、Intruderが他のパラメーターをファジングしているときは"sessid"cookieは更新されます。Intruderが"sessid" cookie 自身をファジングするときは、Burpは"sessid"の値にIntruderのペイロードを送信し、セッションハンドリングルールは正常に行われたように振る舞いますがcookieは更新しません。
            </li>
        </ul>
    </div>
</section>
</body>
</html>