<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="css/ps.css">
</head>
<body>
<section class="container ps-breadcrumbs">
    <ol itemscope itemtype="http://schema.org/BreadcrumbList">
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="https://support.portswigger.net/">
            <span itemprop="name">サポートセンター</span>
            <meta itemprop="position" content="1"/>
            </a>
        </li>
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="index.html">
            <span itemprop="name">ドキュメント</span>
            <meta itemprop="position" content="2"/>
            </a>
        </li>
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="scanner.html">
            <span itemprop="name">Scanner</span>
            <meta itemprop="position" content="3"/>
            </a>
        </li>
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="scanner_options.html">
            <span itemprop="name">オプション</span>
            <meta itemprop="position" content="4"/>
            </a>
        </li>
    </ol>
</section>
<section class="maincontainer">
    <div class="container main">
        <h1>Burp Scannerオプション</h1>
        <p>
            このタブには、Burp Scannerオプションの<a href="#insertionpoints"> 攻撃挿入ポイント</a>、<a href="#engine">アクティブスキャンエンジン</a>、<a href="#activeoptimization">アクティブスキャンの最適化</a>、<a href="#scanissues">スキャン項目</a>、<a href="#staticcodeanalysis">静的コード解析</a>があります。
        </p>
        <a name="insertionpoints"></a>
        <h2>攻撃挿入ポイント</h2>
        <p>
            アクティブスキャンに送られる各ベースリクエストのどこに、"挿入ポイント"をScannerが配置するか制御します。挿入ポイントは、脆弱性を探すために、攻撃を挿入するリクエスト内の位置です。それぞれの定義された挿入ポイントを個別にスキャンします。
        </p>
        <p>
            挿入ポイントの配置位置はきめ細かく設定でき、注意深く設定すれば対象のアプリケーションの性質に合わせたスキャンの調整ができます。挿入ポイントの設定は、スキャンの速度と網羅性のトレードオフになります。
        </p>
        <p>
            <strong>注:</strong> Burpに自動的に挿入ポイントを割り当てさせるだけではなく、全てカスタマイズできるため、ベースリクエスト内の任意の位置を攻撃対象として指定できます。この機能を使うには、リクエストをIntruderに送信し、<a href="intruder_positions.html">ペイロードポジション</a>タブで通常の方法で挿入ポイントを定義し、Intruderメニューオプションから"定義した挿入ポイントをアクティブスキャン"を選択します。または<a href="extender.html">Burp Extender</a>を使って、プログラムでカスタムの挿入ポイントの指定もできます。
        </p>
        <a name="insertionpoints_locations"></a>
        <h3>挿入ポイントの位置</h3>
        <p>
            これらの設定では、挿入ポイントが置かれるリクエスト内の位置を設定できます:
        </p>
        <ul>
            <li>
                <strong>URLパラメーター値</strong> - URLクエリーストリング内の標準的なパラメーター値
            </li>
            <li>
                <strong>ボディのパラメーター値</strong> - メッセージボディのパラメーター値。標準的なフォーム送信パラメーター、アップロードするファイル名などマルチパートエンコードされたパラメーターの属性、XMLパラメーター値と属性、JSONの値があります。
            </li>
            <li>
                <strong>Cookieのパラメーター値</strong> - HTTP cookieの値
            </li>
            <li>
                <strong>パラメーター名</strong> - 任意の追加パラメーター名。URLパラメーターは常に追加され、POSTリクエストではボディパラメーターも追加されます。パラメーター値のみテストしている場合に見逃されているバグを、パラメーター名のテストでよく見つけられます。
            </li>
            <li>
                <strong>HTTPヘッダー</strong> - RefererとUser-Agentヘッダーの値。これらの挿入ポイントのテストによって、ログ機能のSQLインジェクションや永続的なXSSの問題をよく見つけられます。
            </li>
            <li>
                <strong>ボディ全体(関連するコンテントタイプの場合)</strong> - リクエストボディ全体。リクエストボディがXMLまたはJSONのリクエストに適用されます。
            </li>
            <li>
                <strong>AMF文字列パラメーター(使用注意)</strong> - AMFエンコードされたメッセージの任意の文字列データ。<br><strong>注:</strong> BurpはAMFメッセージの解析にサードパーティ製のライブラリを使用します。過去、このライブラリが悪意のあるAMFメッセージを解析する際にセキュリティの脆弱性がありました。信頼されていないアプリケーションの機能やコンテンツにアクセスするとき、このオプションを有効にしないことを推奨します。
            </li>
            <li>
                <strong>URLパスのファイル名</strong> - URLパスのファイル名の部分(最後のフォルダーパスの後ろでクエリーストリングの前)
            </li>
            <li>
                <strong>URLパスのフォルダー</strong> - URLパスの全てのフォルダートークンの値(ファイル名部分の前)。これらの挿入ポイントのテストは大きなオーバーヘッドになるので、これらの場所を送信パラメーターデータに使っていると考えている場合にのみにすべきです。
            </li>
        </ul>
        <a name="insertionpoints_changelocations"></a>
        <h3>パラメーター位置の変更</h3>
        <p>
            これらの設定は、パラメーターの元の位置でのテストに加え、リクエスト内の別の場所に挿入ポイントを移動する設定です。例えば、各URLパラメーターをメッセージボディに移動し再テストができます。または、各ボディパラメーターをcookieに移動し、再テストができます。
        </p>
        <p>
            この方法でパラメーターを移動すると、防御フィルターをバイパスできることがよくあります。多くのアプリケーションやアプリケーションファイアウォールは、パラメーターがリクエスト内の期待している場所にあると仮定してパラメーターごとに入力検証をします。パラメーターを別の場所に移動すると、この検証が回避できます。アプリケーションがその後、メインロジックの実装でそのパラメータを取得する場合、パラメーターの場所に依存しないAPIを使用している可能性があります。よって、通常は処理される前にフィルターされてしまう入力を、脆弱なコードパスに到達させるのにパラメーターの移動は有効です。
        </p>
        <p>
            パラメーター位置の変更は、次のオプションがあります:
        </p>
        <ul>
            <li>
                URLからボディ
            </li>
            <li>
                URLからcookie
            </li>
            <li>
                ボディからURL
            </li>
            <li>
                ボディからcookie
            </li>
            <li>
                cookieからURL
            </li>
            <li>
                cookieからボディ
            </li>
        </ul>
        <p>
            パラメーター位置を変更すると、各リクエストパラメーターが複数回スキャンされることになるため、より多くのスキャンリクストになります。
        </p>
        <a name="insertionpoints_nested"></a>
        <h3>ネストされた挿入ポイント</h3>
        <p>
            挿入ポイントの元の値が認識可能な形式のデータを含む場合に、ネストされた挿入ポイントが使われます。例えば、URLパラメーターにBase64エンコードされたデータがあり、デコードした値にJSONやXMLデータが含まれているなどです。ネストされた挿入ポイントのオプションを使うと、ネストされた各レベルごとに別のそれぞれ別の入力アイテムを挿入ポイントとして作成します。
        </p>
        <p>
            このオプションを使うと、従来通りのリクエストパラメーターのみが含まれるリクエストではオーバーヘッドにはならず、異なる形式でデータがカプセル化された複雑なアプリケーションでより多くの攻撃経路にたどりつけます。
        </p>
        <a name="insertionpoints_max"></a>
        <h3>リクエストあたりの最大挿入ポイント</h3>
        <p>
            どの設定を選択しても、個々のリクエストの挿入ポイント数は一般的に、パラメーターの数などリクエストの機能に依存します。場合によって、リクエストが膨大な量のパラメーター(100以上)を含む場合があります。Burpがすべてのパラメーターのフルスキャンを実行した場合、スキャンの完了には膨大な時間がかかります。
        </p>
        <p>
            この設定では、ベースリクエストごとに生成される挿入ポイントの数に制限を設定し、膨大な数のパラメーターを含むリクエストがあった場合にスキャンが停止するのを防ぎます。この設定により挿入ポイント数が削減されている場合、<a href="scanner_queue.html">アクティブスキャンキュー</a>のアイテムのエントリーには、省略された挿入ポイントの数が表示されるため、手動でベースリクエストをレビューし、可能な全ての挿入ポイントをフルスキャンする価値があるかどうか判断できます。
        </p>
        <a name="insertionpoints_skipping"></a>
        <h3>パラメーターのスキップ</h3>
        <p>
            Burpが特定のテストを省略するリクエストパラメーターを指定します。サーバーサイドインジェクションテスト(SQLインジェクションなど)をスキップする、および全てのチェックをスキップする設定が別にあります。
        </p>
        <p>
            サーバーサイドインジェクションテストは、様々なサーバー上の脆弱性を手探りで調べるために複数のリクエストを送信するので、比較的時間がかかります。リクエスト内の特定のパラメーターに脆弱性がないと考える場合(例えば、プラットフォームやWebサーバのみが使用する組み込みパラメーターなど)、Burpにこれらのテストをしないよう指示できます。(クロスサイトスクリプティングのようなクライアント側のバグのテストは、パラメーターが脆弱ではない場合にスキャン中の負荷が最小限になるよう抑えられています。)
        </p>
        <p>
            テストしたくないアプリケーションコンポーネントに処理されるパラメーターや、変更するとアプリケーションが不安定になると分かっている場合は、全てのテストの省略が便利です。
        </p>
        <p>
            各一覧のアイテムでは、パラメータータイプ、マッチさせるアイテム(名前または値)、マッチの種類(リテラル文字列または正規表現)、マッチさせる文字列を指定します。
        </p>
        <p>
            URLパス内の(スラッシュで区切られた)それぞれのURLパスフォルダーがパラメーターになっている場合があります。これを行うには、検索アイテムのドロップダウンから"URLパスのフォルダー"を、名前または値のドロップダウンで"名前"を選択し、テストから除外したいURLパスのインデックス番号(1オリジン)を指定します。URLパスのフォルダーパラメーターは、値でも指定できます。
        </p>
        <a name="engine"></a>
        <h2>アクティブスキャンエンジン</h2>
        <p>
            アクティブスキャン中にHTTPリクエストを生成するエンジンの挙動を設定します。次のオプションがあります:
        </p>
        <ul>
            <li>
                <strong>同時リクエスト制限</strong> - Scannerが生成できる同時リクエスト数を制御します。
            </li>
            <li>
                <strong>ネットワークエラー時のリトライ回数</strong> - 接続エラーやその他のネットワークの問題が発生した場合、Burpがリクエストを諦めるまでの回数を指定します。テスト中に断続的にネットワーク障害が起こる場合は、失敗時に数回リクエストの再試行をお勧めします。
            </li>
            <li>
                <strong>リトライ前の一次停止</strong> - 失敗したリクエストを再試行する場合、Burpは再試行する前に指定した時間(ミリ秒)待ちます。サーバーのトラフィックを圧迫している場合、または断続的に問題が起きている場合は、再試行前に短時間のウェイトをお勧めします。
            </li>
            <li>
                <strong>リクエスト間のウェイト</strong> - 必要に応じて、Burpは連続するリクエスト間に指定した時間(ミリ秒)ウェイトを入れられます。アプリケーションの負荷を避けたい場合や、こっそりと実行したい場合、このオプションが便利です。
            </li>
            <li>
                <strong>ランダムなウェイトを追加する</strong> - このオプションで、リクエストのタイミングのパターンを減少させると、さらにステルス性を上げられます。
            </li>
            <li>
                <strong>必要な箇所でリダイレクトをたどる</strong> -&nbsp; 一部の脆弱性(例えば、リダイレクトをたどった後に返されるエラーメッセージ内のクロスサイトスクリプティング)は、リダイレクトをたどった場合のみ検出できます。一部のアプリケーションは、送信したパラメーターをURLに含む外部のURLへのリダイレクトを発行することがありますが、外部アプリケーションへの攻撃を防ぐため、Burpは受信したリダイレクトを全てたどるわけではありません。スキャンされているリクエストが定義済みの<a href="target_scope.html">対象スコープ</a>内の場合(つまり、スキャンされる対象を制御するため対象スコープを使用している場合)、同じスコープ内の場合にのみリダイレクトをたどります。スキャンされているリクエストがスコープ外の場合(つまり、スコープ外リクエストのスキャンを手動で開始した場合)は、(a)スキャンしているリクエストと同じホスト/ポートである場合; かつ(b)スコープ除外ルール(例えば"logout.aspx")で明示的に指定されていない場合にのみ、Burpはリダイレクトをたどります。
            </li>
        </ul>
        <p>
            アプリケーションのパフォーマンスに与える影響やあなた自身の処理能力と帯域幅に応じて慎重に設定すると、スキャンエンジンのパフォーマンスの微調整ができます。もしScannerの動作が遅い場合で、ただしアプリケーションのパフォーマンスが良く自分のCPU利用率も低いようであれば、スキャンをするスレッド数を増やせます。接続エラーの発生を見つけた場合で、アプリケーションが遅い場合、または自分のコンピューターがハングアップする場合、スレッド数を減らし、ネットワーク障害時のリトライ回数と再送間隔を増やすべきです。アプリケーションの機能で、一つのベースリクエストで実行されたアクションが他のリクエストからのレスポンスを妨げるような場合、同時に1つのベースリクエストのみスキャンされるようスレッド数を1に減らすことを検討してください。
        </p>
        <a name="activeoptimization"></a>
        <h2>アクティブスキャン最適化</h2>
        <p>
            スキャンの目的や対象アプリケーションの性質を反映して、アクティブスキャンロジックの動作を調整できます。例えば、大規模なアプリケーションでより多くの発見しやすい問題を見つけるために高速なスキャンを選択できますし、見つけにくく多くのスキャンリクエストが必要な問題を発見するため、ゆっくり広範囲なスキャンも実行できます。
        </p>
        <p>
            次のオプションがあります:
        </p>
        <ul>
            <li>
                <strong>スキャンスピード</strong> - 脆弱性をチェックする際に、スキャンチェックをどの程度徹底的に行うかを設定します。"高速”設定は、リクエストが少なくなり、一部の脆弱性でチェックパターンが少なくなります。"徹底的"設定は、より多くのリクエストを発行し、脆弱性のより多くのパターンをチェックします。"標準"設定は、2つの中間で、多くのアプリケーションにとって適切な、速度と徹底性のバランスになります。
            </li>
            <li>
                <strong>スキャン精度</strong> - 特定タイプの脆弱性を報告する場合にScannerが必要とする、証拠の量を設定します。一部の問題は"ブラインド"手法でのみ検出でき、時間遅延やレスポンス差分のような、観測された挙動を元に脆弱性が存在するか推測します。対象の脆弱性が存在しない場合でも、このような挙動はいつでも発生し観測される可能性があるため、エラーメッセージの観測などのような他の手法に比べて、この手法は本質的に過剰検知する傾向にあります。Burpは過剰検知を減らすために、問題を推定したときに何度かテストを繰り返し、送信した入力値と観測した挙動の間に、信頼できる相関があるか確認しようとします。精度設定は、Burpがこれらのテストを何回再試行するか制御します。"検知漏れを最小化"設定は、再試行回数が少なくなり、過剰検知が報告される可能性が高くなりますが、アプリケーションの挙動が安定しない場合でも、存在する脆弱性の見逃しが減ります。"過剰検知を最小化"設定は、再試行回数が多くなり、問題の過剰検知が報告される可能性が低くなりますが、一部のテストリクエストに結果が返ってこないことがあると、存在する問題を誤って見逃す可能性があります。"標準"設定は、2つの中間で、多くのアプリケーションにとって適切な、過剰検知と検知漏れのバランスになります。
            </li>
            <li>
                <strong>賢い攻撃を選択する</strong> - 各挿入ポイントのパラメーターの元値を考慮し、無関係と思われるチェックを省略して、スキャンの効率を向上させます。たとえば、通常はファイル名に使われない文字がパラメーター値に含まれている場合、このパラメーターのファイルパストラバーサルチェックを省略します。このオプションを使用すると、本当は存在する脆弱性を見逃すリスクを比較的低く抑えながら、スキャンの速度を上げられます。
            </li>
        </ul>
        <a name="scanissues"></a>
        <h2>スキャン項目</h2>
        <p>
            Burpがチェックする<a href="https://portswigger.net/kb/issues">項目</a>を制御します。スキャンの種類または個別に、スキャン項目を選択できます。
        </p>
        <p>
            個々の項目を選択する場合、一部の項目で使用される検出方法も選択できます。関連する項目のコンテキストメニューから、"検出手法を編集"を選択します。
        </p>
        <p>
            各チェックを実行すると、生成されるリクエストが増え、各スキャンに時間がかかります。アプリケーションの技術に関する知見を元に、個々の項目のオン/オフを切り替えられます。例えば、アプリケーションがLDAPを使用していないと分かっている場合、LDAPインジェクションをオフにできます。アプリケーションが使用しているバックエンドデータベースが分かっている場合、他のデータベースタイプに固有のSQLインジェクション検出手法をオフにできます。また、スキャンに求める正確性を元に、チェックを選択的に有効にもできます。例えば、アプリケーションを素早くざっと調べるようBurpを設定し、URLとボディパラメーターのXSSとSQLインジェクションのみをチェックしてから、後で全ての挿入ポイントに全ての項目を網羅的にテストできます。
        </p>
        <a name="staticcodeanalysis"></a>
        <h2>静的コード分析</h2>
        <p>
            実行コードの静的解析を含む、スキャンタイプを制御します:
        </p>
        <ul>
            <li>
                アクティブスキャンのみ
            </li>
            <li>
                アクティブとパッシブスキャン
            </li>
            <li>
                静的コード解析を実行しない
            </li>
        </ul>
        <div class="rounded-corner-box">
            <p>
                <strong>注:</strong> 静的解析は大量のメモリと計算能力を消費する可能性があるため、重要で主要な対象のみに制限した方が望ましい場合があります。さらに、静的コード解析を実行する場合は、より多くのメモリを割り当てて<a href="suite_gettingstarted.html#launching">Burpを起動</a>する必要があります。
            </p>
        </div>
        <p>
            スキャンされる個々のアイテムごとに静的解析に費やす最大時間を設定できます。非常に大きく複雑なスクリプトを含むアイテムに遭遇した場合、静的解析エンジンが過剰なシステムリソースを消費する可能性があるため、この設定が便利です。最大時間に達したため分析を中断した場合、その影響を受けたアイテムが特定できる警告を表示します。ゼロまたは空白値を指定すると、無制限が適用されます。
        </p>
    </div>
</section>
</body>
</html>